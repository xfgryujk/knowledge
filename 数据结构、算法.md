# 数据结构

## 数组

数组是连续的一块内存

优点：能随机访问（O(1)）、对CPU缓存友好

缺点：插入、删除元素要移动后面所有元素（O(n)）；扩容时需要重新分配内存，然后把原来的元素全部移动过去

### 应用

* 排序
* 二分查找

## 链表

链表是由内存不连续的结点组成的，每个节点持有下一个结点的指针

优点：插入、删除、移动结点快（O(1)），只需要修改几个指针

缺点：不能随机访问（O(n)）、对CPU缓存不友好

### 应用

* 链表的拼接、反转是主要考点
* 检测是否有环：快慢指针法，快指针一次走两步，慢指针一次走一步，如果相遇了，就是有环
* 寻找环的入口：快慢指针法相遇后，再用一个额外的指针从入口和慢指针一起走，相遇的结点就是入口

## 栈

栈是后进先出的数据结构，一般只能操作栈顶，在栈顶访问、添加、删除元素

底层一般由数组、链表、分段数组（`std::deque`）实现

### 应用

* DFS
* 括号匹配
* 表达式计算
* 单调栈

## 队列

队列是先进先出的数据结构，一般只能在队首访问、删除元素，在队尾添加元素

底层一般由链表、分段数组实现

### 应用

* BFS

## 哈希表

哈希表特点是能以平均O(1)的复杂度快速查找元素

底层实现先用哈希函数算出元素的哈希值，然后对数组容量取模，放到对应的数组下标。如果有多个元素的数组下标相同，则把它们用链表存储

优点：平均情况下能以O(1)的复杂度快速查找元素

缺点：最坏情况下，所有元素的数组下标都相同，这时查找元素的复杂度会变成O(n)；元素的存储是无序的，不支持范围查找

## 树

树是一种特殊的无环图。每个结点持有子树的指针，没有子树的结点则是叶子结点。树是一种递归的结构，具有上下级关系，这是它和图最主要的区别

### 二叉树

二叉树是每个结点最多有两个子树的树。二叉树是最常用的树结构，因为可以根据条件是否成立决定接下来遍历左子树还是右子树。根据结点的数量还可以分为：

* 完全二叉树：除了最后一层，其他层的结点数都达到最大值，且最后一层的结点都在左边，右边可以是空的。完全二叉树可以用数组来表示，子结点的下标可以由父结点的下标算出来
* 满二叉树：所有层的结点数都达到最大值

BFS按根结点被遍历的顺序，可以分为以下的遍历方式：

* 前序遍历：根结点、左子树、右子树
* 中序遍历：左子树、根结点、右子树
* 后序遍历：左子树、右子树、根结点

DFS就是按层级遍历

### 二叉搜索树

二叉搜索树的左子树结点的值 < 根结点的值，右子树结点的值 > 根结点的值

重要性质：二叉搜索树的中序遍历结果是一个升序排序的数组

二叉搜索树是用于搜索的数据结构，如果要搜索的目标 < 当前结点值则到左子树继续搜索，如果要搜索的目标 > 当前结点值则到右子树继续搜索。平均搜索复杂度是O(logN)，最坏情况下，所有结点形成一个链表，搜索的复杂度变成O(N)

为了避免搜索复杂度退化，需要尽量保证二叉树结构平衡。常用的平衡树：

* AVL树：保证任意左右子树的高度差 <= 1。因为严格保证平衡，搜索的复杂度低，但是插入、删除需要的旋转操作多
* 红黑树：是一种弱平衡树，保证从根结点到叶子结点的最长路径不会超过最短路径的2倍。插入、删除需要的旋转操作少

红黑树的性质：

* 每个结点要么是红的要么是黑的
* 根结点是黑的
* 每个叶子结点（即NULL结点）都是黑的
* 如果一个结点是红的，那么它的两个儿子都是黑的
* 任意结点到叶子结点（NULL结点）的每条路径都包含相同数目的黑结点

### 字典树/前缀树

字典树是一种多叉树，用于搜索字典中的字符串。字典树根结点是空字符串，从根结点到其他结点的路径构成了这个结点对应的字符串。字典树利用字符串的公共前缀来减少搜索时间，最大限度地减少无谓的字符串比较

## 堆

堆是一种完全二叉树，用于动态求最大值、最小值。堆分为最大堆、最小堆。最大堆的结点的值 >= 其子结点的值，根结点就是值最大的结点

因为它是一种完全二叉树，所以底层一般用数组实现。结点的`数组下标 * 2 + 1`就是左子结点的数组下标；结点的`数组下标 * 2 + 2`就是右子结点的数组下标；结点的`(数组下标 - 1) / 2`就是父结点的下标

以最大堆为例的实现：

* 添加结点时，先添加到数组末尾，然后向上调整：如果父结点 < 子结点，则交换，一直到根结点
* 删除根结点时，先把数组末尾的结点移动到根结点，然后向下调整：如果最大的子结点 > 父结点，则交换，一直到叶子节点

### 应用

* 优先队列
* top K问题
* 堆排序

## 图

图是多个结点、结点之间的边组成的数据结构。图分为无向图、有向图，有向图的边只能从一个结点走到另一个结点，而不能反向走。图常用邻接矩阵、邻接表表示

邻接矩阵是二维数组，里面的值表示两个结点之间的关系，比如是否连通、权重是多少。优点是直观、容易获取两个结点的关系。缺点是对于边数少的稀疏图会浪费空间

邻接表是链表的数组，每个结点对应一个链表，链表的值表示与该点连通的另一个结点。优点是对于稀疏图占用的空间少。缺点是要找到和另一个结点的关系必须遍历边

### 应用

* BFS
* DFS
* 最短路径
* 并查集

# 算法

## 排序

## 分治法

## 搜索

## 动态规划

## 位运算
