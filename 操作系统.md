# 进程
进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位

进程和线程的区别：

* 进程是资源分配的单位，线程是CPU调度的单位
* 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
* 进程之间是独立的，但同一个进程中的线程共享内存（代码和数据）、打开的文件、信号等资源

但是在Linux下进程和线程的结构体都是`task_struct`，线程只是共享内存等资源的task，没有对进程和进程区别对待

多线程相对于多进程的优点：

* 传递数据更简单，因为内存是共享的
* 上下文切换的成本更小，因为同一个进程内不用切换页表
* 内存占用更少

缺点：

* 一个线程崩溃会导致整个进程崩溃


## 状态
基本的三态模型：

* 运行：正在占用CPU运行中
* 就绪：可以运行，但是还没获得CPU资源
* 阻塞：正在等待某一事件（比如IO完成）发生，无法运行

五态模型在三态的基础上加了新建、终止：

* 新建：进程刚刚创建，准备进入就绪状态
* 终止：进程已经运行结束，准备释放资源

七态模型在五态模型的基础上加了挂起，挂起是指把进程切换到外存（硬盘）了：

* 就绪挂起：进程在外存，但只要进入内存，立刻可以运行
* 阻塞挂起：进程在外存，正在等待某一事件发生

Linux的进程状态：

* 可执行 D（TASK_RUNNING）：相当于运行 + 就绪，正在CPU的可执行队列中，可能正在执行
* 可中断的睡眠 S（TASK_INTERRUPTIBLE）：正在等待某一事件发生
* 不可中断的睡眠 D（TASK_UNINTERRUPTIBLE）：和可中断的睡眠类似，但是这时候不能响应信号（可以响应中断）。这个状态意义在于，要保护内核的某些流程不被打断
* 暂停、跟踪 T（TASK_STOPPED、TASK_TRACED）：收到了SIGSTOP信号，或者正在被调试暂停
* 退出、僵尸 Z（TASK_DEAD - EXIT_ZOMBIE）：进程的大部分资源都被释放了，只留下task_struct等少数资源。里面存储了退出码和一些统计信息，等待父进程获取

僵尸进程太多了怎么办：僵尸进程用kill是杀不掉的，应该将父进程杀掉，然后僵尸进程才会消失。有僵尸进程说明父进程没有正确调用`wait`来释放子进程的结构，正常做法应该是父进程处理SIGCHLD信号，在信号处理中调用`wait`；或者直接设置忽略SIGCHLD信号


## 调度算法
[参考](https://xiaolincoding.com/os/4_process/process_base.html#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)

进程状态变化时，系统要决定下次该让哪个进程运行，主要有以下的算法

### 先来先服务
非抢占式，每次选择就绪队列中最先进入队列的进程

缺点：如果长进程先运行，那么后面的短进程等待的时间会很长

适用于CPU密集型进程，不适用于IO密集型

### 最短作业优先
非抢占式，每次选择（估计的）运行时间最短的进程运行

优点：降低了进程的平均等待时间，提高了吞吐量

缺点：短进程太多时，会导致长进程饥饿

### 高响应比优先
非抢占式，对每个进程计算响应比优先级，选择优先级最高的进程运行。`优先级 = 1 + 等待时间 / （估计的）要求的服务时间`。所以短进程和等待时间太长的进程会优先运行

优点：权衡了长进程和短进程

缺点：要求的服务时间不可预知，所以这只是理想的调度算法

### 时间片轮转
每个进程分配一个时间片运行，时间片用完时进程会被抢占，回到队尾

优点：长进程和短进程都有机会运行

缺点：需要考虑时间片的长度，如果太长就变成了先来先服务，如果太短会导致频繁的切换上下文。另外不支持优先级

### 最高优先级
每次选择优先级最高的进程运行

优先级分类：

* 静态优先级：用户设置的固定的优先级
* 动态优先级：根据进程运行状况动态调整的优先级。比如运行时间长的降低优先级，等待时间长的提高优先级

出现更高优先级进程时的处理：

* 非抢占式：当就绪队列出现更高优先级的进程时，等到当前进程运行完再让更高优先级的进程运行
* 抢占式：当就绪队列出现更高优先级的进程时，当前进程挂起，选择更高优先级的进程运行

### 多级反馈队列
有多个优先级队列，优先级越高的时间片越短。新的进程放到最高优先级的队尾。如果在规定的时间片内没运行完，则把进程转入下一级的队列末尾。当出现更高优先级的进程时，会抢占当前进程

优点：兼顾了长短进程，响应时间也比较好

### Linux的进程调度
[参考](https://man7.org/linux/man-pages/man7/sched.7.html)

每个静态优先级有一个可运行队列，调度策略指定进程会被插入哪个队列和它在队里里怎么移动。调度器选择目前优先级最高的非空队列的第一个进程运行

调度策略，优先级从高到低：

* 限期进程，nice值无影响
    * 全局最早期限优先（SCHED_DEADLINE）：每个周期内运行一次，在期限内必须运行完成
* 实时进程，静态优先级从99到1，nice值无影响
    * 先进先出（SCHED_FIFO）：无时间片，一直运行直到阻塞、被更高优先级抢占、主动调度
    * 时间片轮转（SCHED_RR）：和FIFO差不多，除了有时间片
* 普通进程，静态优先级必须是0，nice值从-20到19
    * 默认（SCHED_NORMAL、SCHED_OTHER）：按照动态优先级调度。动态优先级基于nice值计算，并且每次就绪但未能调度时会增加
    * 批处理（SCHED_BATCH）：和默认差不多，但是调度器会假设进程是CPU密集型的，在它唤醒时给个小的惩罚，使它更少被调度。这个策略用于不想降低nice值的非交互式程序
* 空闲进程，静态优先级必须是0，nice值无影响
    * 空闲（SCHED_IDLE）：极低优先级，只有空闲时才运行，可以被任意进程抢占

普通进程的调度算法，完全公平调度（Completely Fair Scheduler）：在时间片轮转的基础上引入了加权计算的虚拟运行时间（vruntime）。完全公平指的是vruntime公平，调度器尽量让每个进程的vruntime相同，每次选择vruntime最小的进程运行。nice值越大，vruntime增长越快，进程就越少被运行


## Linux的进程结构
[参考](https://blog.csdn.net/gatieme/article/details/51383272)

Linux中进程和线程的结构体是`task_struct`，它主要包含这些信息：

* 标识符：pid、tgid等
* 状态：运行、阻塞等状态
* 内核栈：内核态的栈、线程描述符
* 标记：反应进程状态的信息，但不是运行状态
* 亲属关系：父进程、子进程列表
* 追踪信息：用于断点调试
* 调度：优先级、调度策略
* 地址空间：描述整个虚拟内存的`mm_struct`结构，包含各个段的区间、页表等信息
* 统计：运行时间等统计信息
* 文件系统：进程的当前目录、根目录、打开的文件信息
* 信号：信号处理描述


## 创建新进程
参考：

* [fork](https://linux.die.net/man/2/fork)
* [execve](https://linux.die.net/man/2/execve)
* [clone](https://linux.die.net/man/2/clone)

创建新进程的方法：

1. `fork`从当前进程复制出一个新进程。新进程会从`fork`返回处继续执行，子进程的返回值是0，父进程的返回值是子进程的pid。此时父子进程的内存空间是相同的，只有它们第一次写的时候会触发复制，使它们的内存分开，这叫写时复制（copy-on-write）
2. exec系列函数使用指定程序（包括代码、数据）替换当前进程。替换之后原来程序后面的代码就不再执行了，取而代之新的程序会从头开始执行

Linux中创建进程、线程最后都是到内核的`do_fork`函数。线程比进程多了一些flag：`CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD`。从字面上看，线程会共享虚拟地址空间、文件、信号等资源

写时复制的实现：`fork`之后先把两个进程的内存设置为只读属性，写入时触发异常，然后再复制内存

`fork`只是把`task_struct`和页表复制了一份，父子进程会共享很多资源，包括：

* 物理内存此时是相同的，只有第一次写入的时候会复制分离成两份。Redis会利用这个特性在子进程中将内存中的数据存盘
* 打开的文件描述符是相同的。父子进程可以利用这个共享匿名管道来通信
* 信号处理表
* 进程组ID、会话ID、用户ID等
* 当前目录、根目录

exec系列函数保留的旧程序资源包括：

* pid、父进程pid、用户ID、nice值等属性
* 打开的文件描述符（除了设置了FD_CLOEXEC的）
* 环境变量（有的exec函数支持设置成其他环境变量）
* 当前目录、根目录

`fork`和`vfork`的区别：最初`fork`是没有写时复制的，如果`fork`后跟exec就白复制内存了，所以出了个不复制内存版的`vfork`。`vfork`不会复制页表，在子进程中修改内存会影响到父进程。调用`vfork`后父进程会阻塞，直到子进程退出或者调用了exec


## Linux的进程间通信
### 管道

### 消息队列

### 套接字

### 信号

### 共享内存

### 信号量


# 内存
## Linux进程的内存结构


## 虚拟内存


## 分页


## 分段


## 置换算法
