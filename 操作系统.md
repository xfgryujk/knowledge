# 进程

进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位

进程和线程的区别：

* 进程是资源分配的单位，线程是CPU调度的单位
* 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
* 进程之间是独立的，但同一个进程中的线程共享内存（代码和数据）、打开的文件、信号等资源

但是在Linux下进程和线程的结构体都是`task_struct`，线程只是共享内存等资源的task，没有对进程和进程区别对待

多线程相对于多进程的优点：

* 传递数据更简单，因为内存是共享的
* 上下文切换的成本更小，因为同一个进程内不用切换页表
* 内存占用更少

缺点：

* 一个线程崩溃会导致整个进程崩溃

## 状态

基本的三态模型：

* 运行：正在占用CPU运行中
* 就绪：可以运行，但是还没获得CPU资源
* 阻塞：正在等待某一事件（比如IO完成）发生，无法运行

五态模型在三态的基础上加了新建、终止：

* 新建：进程刚刚创建，准备进入就绪状态
* 终止：进程已经运行结束，准备释放资源

七态模型在五态模型的基础上加了挂起，挂起是指把进程切换到外存（硬盘）了：

* 就绪挂起：进程在外存，但只要进入内存，立刻可以运行
* 阻塞挂起：进程在外存，正在等待某一事件发生

Linux的进程状态：

* 可执行 R（TASK_RUNNING）：相当于运行 + 就绪，正在CPU的可执行队列中，可能正在执行
* 可中断的睡眠 S（TASK_INTERRUPTIBLE）：正在等待某一事件发生
* 不可中断的睡眠 D（TASK_UNINTERRUPTIBLE）：和可中断的睡眠类似，但是这时候不能响应信号（可以响应中断）。这个状态意义在于，要保护内核的某些流程不被打断
* 暂停、跟踪 T（TASK_STOPPED、TASK_TRACED）：收到了SIGSTOP信号，或者正在被调试暂停
* 退出、僵尸 Z（TASK_DEAD - EXIT_ZOMBIE）：进程的大部分资源都被释放了，只留下task_struct等少数资源。里面存储了退出码和一些统计信息，等待父进程获取

僵尸进程太多了怎么办：僵尸进程用kill是杀不掉的，应该将父进程杀掉，然后僵尸进程才会消失。有僵尸进程说明父进程没有正确调用`wait`来释放子进程的结构，正常做法应该是父进程处理SIGCHLD信号，在信号处理中调用`wait`；或者直接设置忽略SIGCHLD信号

## 调度算法

[参考](https://xiaolincoding.com/os/4_process/process_base.html#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)

进程状态变化时，系统要决定下次该让哪个进程运行，主要有以下的算法

### 先来先服务

非抢占式，每次选择就绪队列中最先进入队列的进程

缺点：如果长进程先运行，那么后面的短进程等待的时间会很长

适用于CPU密集型进程，不适用于IO密集型

### 最短作业优先

非抢占式，每次选择（估计的）运行时间最短的进程运行

优点：降低了进程的平均等待时间，提高了吞吐量

缺点：短进程太多时，会导致长进程饥饿

### 高响应比优先

非抢占式，对每个进程计算响应比优先级，选择优先级最高的进程运行。`优先级 = 1 + 等待时间 / （估计的）要求的服务时间`。所以短进程和等待时间太长的进程会优先运行

优点：权衡了长进程和短进程

缺点：要求的服务时间不可预知，所以这只是理想的调度算法

### 时间片轮转

每个进程分配一个时间片运行，时间片用完时进程会被抢占，回到队尾

优点：长进程和短进程都有机会运行

缺点：需要考虑时间片的长度，如果太长就变成了先来先服务，如果太短会导致频繁的切换上下文。另外不支持优先级

### 最高优先级

每次选择优先级最高的进程运行

优先级分类：

* 静态优先级：用户设置的固定的优先级
* 动态优先级：根据进程运行状况动态调整的优先级。比如运行时间长的降低优先级，等待时间长的提高优先级

出现更高优先级进程时的处理：

* 非抢占式：当就绪队列出现更高优先级的进程时，等到当前进程运行完再让更高优先级的进程运行
* 抢占式：当就绪队列出现更高优先级的进程时，当前进程挂起，选择更高优先级的进程运行

### 多级反馈队列

有多个优先级队列，优先级越高的时间片越短。新的进程放到最高优先级的队尾。如果在规定的时间片内没运行完，则把进程转入下一级的队列末尾。当出现更高优先级的进程时，会抢占当前进程

优点：兼顾了长短进程，响应时间也比较好

### Linux的进程调度

[参考](https://man7.org/linux/man-pages/man7/sched.7.html)

每个静态优先级有一个可运行队列，调度策略指定进程会被插入哪个队列和它在队里里怎么移动。调度器选择目前优先级最高的非空队列的第一个进程运行

调度策略，优先级从高到低：

* 限期进程，nice值无影响
    * 全局最早期限优先（SCHED_DEADLINE）：每个周期内运行一次，在期限内必须运行完成
* 实时进程，静态优先级从99到1，nice值无影响
    * 先进先出（SCHED_FIFO）：无时间片，一直运行直到阻塞、被更高优先级抢占、主动调度
    * 时间片轮转（SCHED_RR）：和FIFO差不多，除了有时间片
* 普通进程，静态优先级必须是0，nice值从-20到19
    * 默认（SCHED_NORMAL、SCHED_OTHER）：按照动态优先级调度。动态优先级基于nice值计算，并且每次就绪但未能调度时会增加
    * 批处理（SCHED_BATCH）：和默认差不多，但是调度器会假设进程是CPU密集型的，在它唤醒时给个小的惩罚，使它更少被调度。这个策略用于不想降低nice值的非交互式程序
* 空闲进程，静态优先级必须是0，nice值无影响
    * 空闲（SCHED_IDLE）：极低优先级，只有空闲时才运行，可以被任意进程抢占

普通进程的调度算法，完全公平调度（Completely Fair Scheduler）：在时间片轮转的基础上引入了加权计算的虚拟运行时间（vruntime）。完全公平指的是vruntime公平，调度器尽量让每个进程的vruntime相同，每次选择vruntime最小的进程运行。nice值越大，vruntime增长越快，进程就越少被运行

## Linux的进程结构

[参考](https://blog.csdn.net/gatieme/article/details/51383272)

Linux中进程和线程的结构体是`task_struct`，它主要包含这些信息：

* 标识符：pid、tgid等
* 状态：运行、阻塞等状态
* 内核栈：内核态的栈、线程描述符
* 标记：反应进程状态的信息，但不是运行状态
* 亲属关系：父进程、子进程列表
* 追踪信息：用于断点调试
* 调度：优先级、调度策略
* 地址空间：描述整个虚拟内存的`mm_struct`结构，包含各个段的区间、页表等信息
* 统计：运行时间等统计信息
* 文件系统：进程的当前目录、根目录、打开的文件信息
* 信号：信号处理描述

## 创建新进程

参考：

* [fork](https://linux.die.net/man/2/fork)
* [execve](https://linux.die.net/man/2/execve)
* [clone](https://linux.die.net/man/2/clone)

创建新进程的方法：

1. `fork`从当前进程复制出一个新进程。新进程会从`fork`返回处继续执行，子进程的返回值是0，父进程的返回值是子进程的pid。此时父子进程的内存空间是相同的，只有它们第一次写的时候会触发复制，使它们的内存分开，这叫写时复制（copy-on-write）
2. exec系列函数使用指定程序（包括代码、数据）替换当前进程。替换之后原来程序后面的代码就不再执行了，取而代之新的程序会从头开始执行

Linux中创建进程、线程最后都是到内核的`do_fork`函数。线程比进程多了一些flag：`CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD`。从字面上看，线程会共享虚拟地址空间、文件、信号等资源

写时复制的实现：`fork`之后先把两个进程的内存设置为只读属性，写入时触发异常，然后再复制内存

`fork`只是把`task_struct`和页表复制了一份，父子进程会共享很多资源，包括：

* 物理内存此时是相同的，只有第一次写入的时候会复制分离成两份。Redis会利用这个特性在子进程中将内存中的数据存盘
* 打开的文件描述符是相同的。父子进程可以利用这个共享匿名管道来通信
* 信号处理表
* 进程组ID、会话ID、用户ID等
* 当前目录、根目录

exec系列函数保留的旧程序资源包括：

* pid、父进程pid、用户ID、nice值等属性
* 打开的文件描述符（除了设置了FD_CLOEXEC的）
* 环境变量（有的exec函数支持设置成其他环境变量）
* 当前目录、根目录

`fork`和`vfork`的区别：最初`fork`是没有写时复制的，如果`fork`后跟exec就白复制内存了，所以出了个不复制内存版的`vfork`。`vfork`不会复制页表，在子进程中修改内存会影响到父进程。调用`vfork`后父进程会阻塞，直到子进程退出或者调用了exec

## Linux的进程间通信

### 管道

管道代表内核中一段缓冲区，它有读端、写端两个fd，可以像文件一样操作。写端写进去的数据可以从读端读取。管道是单工的，双向通信需要创建两个管道

管道分为匿名管道（pipe）和命名管道（FIFO）。它们的区别只在于创建和打开方式，打开后对它们的IO具有相同的语义。匿名管道用于父子进程间通信，因为父子进程可以方便地传递fd。命名管道用于任意进程间通信，创建后任意进程都可以打开来读或写，而且进程结束后命名管道不会自动释放

```c++
// 创建匿名管道
int fds[2]{}; // 0是读端fd，1是写端fd
pipe(fds);

// 在文件系统指定位置创建命名管道
mkfifo("./myfifo.fifo", 0644);
int read_fd = open("./myfifo.fifo", O_RDONLY); // open会阻塞直到对端open
// 另一个进程
int write_fd = open("./myfifo.fifo", O_WRONLY); // open会阻塞直到对端open
```

### 消息队列

消息队列代表内核中的一个链表。和管道的区别：消息队列是基于消息的，而管道是基于字节流的；读写消息队列是异步的，而管道open时会阻塞直到对端open

消息队列不适合传输大的数据，内核会限制每个消息的大小和队列里面消息总大小

```c++
struct MsgBuf {
    long type = 1; // 必须 > 0
    char body[1024]{};
};
constexpr key_t MQ_KEY = 1234;

int mq_id1 = msgget(MQ_KEY, IPC_CREAT | 0644);
MsgBuf msg_to_send;
strcpy(msg_to_send.body, "test");
msgsnd(mq_id1, &msg_to_send, sizeof(msg_to_send.body), 0);

// 另一个进程
int mq_id2 = msgget(MQ_KEY, IPC_CREAT | 0644);
MsgBuf msg_buffer;
msgrcv(mq_id2, &msg_buffer, sizeof(msg_buffer.body), 0, 0);
cout << msg_buffer.body << endl; // test

// 进程结束消息队列也不会释放，必须手动释放
msgctl(mq_id1, IPC_RMID, nullptr);
```

### 套接字

套接字既能用于本地进程间通信，也能用于不同主机进程间通信。可以用基于字节流的协议（TCP）和基于消息的协议（UDP）。本地进程间通信还可以用Unix域套接字，与普通套接字相比，它绑定的不是端口，而是本地的文件路径；它不用走协议栈，内核只是把缓冲区指针传递给对端，性能更高；使用基于消息的协议也是可靠的，不会丢消息

### 信号

信号用于通知发生了某个事件，不会携带数据。给目标进程发送信号，就会调用它的信号处理函数，类似于中断处理函数。SIGKILL用于强制杀进程，不可捕获；SIGTERM用于停止进程，可以捕获；SIGINT是用户按下Ctrl + C请求中断；一些服务器约定使用SIGHUP重新加载配置

### 共享内存

可以让不同进程的一块虚拟地址空间映射到同一块物理内存，这样一个进程写入数据，另一个进程能立即读到。共享内存会有竞争条件的问题，需要配合信号量等同步机制使用。共享内存是最快的进程间通信方法，因为不需要拷贝，就可以直接使用相同的数据

```c++
// System V 接口
constexpr key_t SHM_KEY = 1234;

int shm_id = shmget(SHM_KEY, 1024, IPC_CREAT | 0644);

if (fork() == 0) {
    void* shm_ptr = shmat(shm_id, nullptr, 0);
    // 子进程写入共享内存
    strcpy((char*)shm_ptr, "test");
    return 0;
}

this_thread::sleep_for(1s);
void* shm_ptr = shmat(shm_id, nullptr, 0);
// 父进程从共享内存中读取
cout << (char*)shm_ptr << endl; // test

// 标记要释放共享内存，最后一个进程与指定的共享内存分离后才会释放
shmctl(shm_id, IPC_RMID, nullptr);


// 也可以用mmap接口实现，这是POSIX标准
void* shm_ptr = mmap(nullptr, 1024, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);

if (fork() == 0) {
    // 子进程写入共享内存
    strcpy((char*)shm_ptr, "test");
    return 0;
}

this_thread::sleep_for(1s);
// 父进程从共享内存中读取
cout << (char*)shm_ptr << endl; // test
```

### 信号量

信号量用来控制同时访问资源的线程数量，允许同时有多个线程访问，但数量不能超过一定量。它不是用来保证线程安全的，而是用来控制并发数的，但也可以当做锁或条件变量用

通过两个原子操作的系统调用来控制信号量：

* P操作：将信号量的值-1，如果< 0，则说明当前使用资源的线程太多，阻塞当前线程
* V操作：将信号量的值+1，如果<= 0，则说明有其他线程正在等待，唤醒一个等待中的线程

# 内存

## Linux进程的内存结构

从高地址到低地址分别是：

* 内核空间：用户态不可访问的内核空间。进程切换时这一段不会变，所以内核里的地址对于每个进程都是相同的
* 栈：具有自动存储期的局部变量、参数、返回地址等。增长方向是从高地址向低地址增长，新创建的线程的栈也是从高地址向低地址增长
* 内存映射段：`mmap`动态分配的内存，文件映射和匿名映射，包括动态链接库。增长方向在不同的内核版本和CPU字长中不同，我自己用x64 Linux 5测试是从高地址向低地址增长
* 堆：`brk`动态分配的内存。增长方向是从低地址向高地址增长
* 未初始化的数据段（BSS）：具有静态存储期且未初始化的变量，比如`char str[100];`。初始化时系统会用0填充这一段
* 已初始化的数据段：具有静态存储期且初始化的变量，比如`int i = 1;`。初始化内容是编译器写在可执行文件里的
* 文本段（Text）：代码、字符串常量。这段内存是只读属性的

32位系统中，内核空间占1GB，用户空间占3GB；64位系统中内核和用户各占128TB，中间的部分是未定义的

## 虚拟内存

[参考](https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)

虚拟内存是在CPU和物理内存之间的中间层，CPU发出读取虚拟地址的指令，内存管理单元（MMU）把虚拟地址映射成物理地址，再访问物理内存

为什么需要虚拟内存：

* 为了同时加载不同的程序。引入虚拟内存，不同的程序可以使用相同的地址而互不影响。如果没有虚拟内存只能在编译时确定内存地址，让不同的程序不冲突
* 为了隔离不同进程，一个进程的内存错误不影响其他进程；不能随意读取其他进程的敏感数据
* 支持加载大于物理内存的程序，暂时用不到的内存可以先换出到硬盘，只要访问时再换入到物理内存就行

虚拟内存和物理内存地址映射的方式主要有分段和分页

### 分段

把内存分成大小不同的逻辑段，不同段具有不同的属性，比如代码段、数据段、栈段等。内存地址的高位用来索引段表，段表中存储了段的基址，内存地址的低位是段内偏移量，基址 + 偏移量就是物理内存的地址

缺点：

* 容易产生外部内存碎片
* 内存交换慢，每次都要把整个段换出到硬盘

### 分页

把虚拟内存和物理内存分成大小相同的页，一般是4kB。内存地址的高位用来索引页表，页表中存储了页的基址，内存地址的低位是页内偏移量，基址 + 偏移量就是物理内存的地址

缺点：页表的大小很大，4GB内存分成每页4kB就需要4MB的页表

为了解决页表太大的问题，引入了多级页表。比如二级页表，如果某个一级页表项没有被用到，就不需要创建这个页表项对应的二级页表了。因为局部性原理，分配的页大多都是相邻的，所以空着的二级页表很多。32位系统一般用二级页表，64位系统一般用四级页表

多级页表虽然解决了页表太大的问题，但是增加了转换的步骤，带来了时间上的开销。所以CPU引入了页表缓存（TLB，Translation Lookaside Buffer），在寻址时先查TLB，如果没有再查常规的页表

### 段页式

先把内存分成大小不同的逻辑段，再把每个段分成大小相同的页。内存地址由段号、段内页号、页内偏移量组成

x86支持的就是段页式内存管理。但Linux会把每个段都设置成从0开始的整个地址空间，相当于不用段式管理，只用页式管理

## 页面置换算法

[参考](https://xiaolincoding.com/os/5_schedule/schedule.html#%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)

当物理内存满时，需要选择一个物理页，把它换出到磁盘，主要有以下的算法

### 最佳页面置换

置换在未来最长时间不使用的页面。这是最理想的算法，但是无法预知页面在下一次使用的时间，所以无法实现。这个算法用来衡量其他算法的效率，越接近这个算法的效率越高

### 先进先出

置换最先装入内存的页面

缺点：没有考虑使用频率，可能使用频率高的页面被频繁换出

### 最近最久未使用

Least Recently Used，置换最长时间没有被访问过的页面。这个算法假设之前很久没被使用的页面在未来较长的一段时间也不会被使用

缺点：有缓存污染问题，没考虑频率，可能有最近只被访问一次就不用的页面

### 时钟页面置换

对FIFO和LRU的一种改进

1. 把所有页面保存在一个类似时钟的环形链表，一个指针指向最老的页面
2. 首先检查指针指向的页面，如果它的访问位是0就淘汰该页面，把新的页面插入这个位置，然后把指针往前移动
3. 如果访问位是1就清除访问位，并把指针往前移动，重复这个过程直到找到访问位为0的页面

### 使用频率最小

Least Frequently Used，置换访问频率（次数）最小的页面

缺点：有缓存污染问题，没考虑时间，可能有页面在过去访问频率很高，但是现在不访问了。不过可以定期减少访问计数来解决

### Linux的页面置换

Linux改进了LRU，区分了热数据和冷数据，将一个链表改成两个链表：活跃LRU链表、非活跃LRU链表。新页面先进入非活跃链表，只有第二次访问时，才进入活跃链表。淘汰时优先淘汰非活跃链表
