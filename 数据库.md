# 基础知识

SQL和NoSQL的区别：

* SQL是关系型数据库，用二维表格组织数据，有哪些字段、字段类型是固定的；NoSQL是非关系型数据库，可以不用行和列，而用更合适的格式组织数据，比如键值对（Redis）、文档（MongoDB）
* SQL提供ACID保证的事务；NoSQL一般只提供阉割版事务，这也是它快的原因
* SQL可以垂直（单机）扩展；NoSQL基于CAP、BASE理论，可以水平（分布式）扩展

常见的SQL数据库：MySQL、PostgreSQL、Oracle Database、Microsoft SQL Server

常见的NoSQL数据库：Redis、MongoDB、Elasticsearch

CAP定理：一个分布式系统最多只能同时满足CAP三项中的两项

* 一致性（Consistence）：每个请求都返回最新数据或者错误
* 可用性（Availability）：每个请求都有无错误的响应，但不保证是最新的数据
* 分区容错性（Partition tolerance）：节点之间的任何信息延迟或丢失都不会停止整个系统运行

为什么不能同时满足三项：

* 因为网络故障不可避免，所以分区容错性必须被满足，否则只能部署单节点，这就违背了分布式的初衷
* 如果要满足一致性，只能等待数据同步完后才能服务，但网络分区可能导致数据同步时间无限延长，就会导致超时和出错的响应，不能满足可用性
* 如果要满足可用性，节点可以只用本地的数据提供服务，但不能保证数据是最新的，不能满足一致性

BASE理论：即使无法做到强一致性，但每个应用可以根据自身的业务特点，保证弱一致性

* 基本可用（Basically Available）：出现故障的时候，允许损失部分可用性
* 软状态（Soft state）：允许系统存在中间状态，而该中间状态不会影响系统整体可用性
* 最终一致性（Eventually consistent）：系统中的所有数据副本经过一定时间后，最终能够达到一致的状态

# MySQL

## 引擎

MySQL支持的数据库引擎有InnoDB、MyISAM，它们的区别：

* InnoDB支持事务，MyISAM不支持事务
* InnoDB支持外键，MyISAM不支持外键
* InnoDB使用聚簇索引，数据在文件中存储的顺序就是聚簇索引（主键）的顺序，即使没指定主键也会自动生成隐式的主键；MyISAM不支持聚簇索引
* InnoDB不存储表的行数，`COUNT(*)`需要全表扫描；MyISAM会存储表的行数
* InnoDB最小粒度的锁是行锁，MyISAM最小粒度的锁是表锁
* InnoDB使用日志保证可靠性；MyISAM不保证可靠性，崩溃后无法安全恢复

MySQL 5.5之后默认的数据库引擎是InnoDB，以下的讨论都是基于InnoDB的

## 索引

[参考](https://xiaolincoding.com/mysql/index/index_interview.html)

索引是帮助快速查找数据的数据结构，建索引是为了用空间换时间。索引不能建太多，否则会占用大量空间，而且写数据会变慢，因为还要维护索引

### 数据结构

MySQL的索引数据结构是B+树。B+树是多叉树，只有叶子节点存储数据，非叶子节点只存储索引不存数据，叶子节点之间用双向链表连接

为什么使用B+树：

* 相对于二叉树：多叉树的高度更小，读取每层需要一次磁盘IO，用多叉树就减少了大量IO次数。MySQL的B+树一般3层就可以存储上千万数据
* 相对于B树：
    * B+树的非叶子节点不存储数据，可以容纳更多索引，高度比B树更小
    * B+树的叶子节点之间用链表连接，范围查找的时候遍历更方便，而B树的遍历会涉及不同层级，增加IO次数
    * B+树插入、删除时树的变形更少，效率更高
* 相对于哈希表：
    * B+树的结点是有序的，范围查找的时候只需要从边界遍历，而哈希表是无序的
    * 哈希表在冲突较多的时候需要重哈希，会移动所有结点

### 分类

按物理存储分：

* 聚簇索引（主键索引）：叶子节点存储的是实际数据。如果指定了主键则主键就是聚簇索引，否则如果有不含NULL的唯一键则把它作为聚簇索引，如果都没有则隐式生成一个自增的的ID列作为聚簇索引
* 二级索引（辅助索引）：叶子节点存储主键。如果需要其他数据则需要回表，即根据主键再次查找聚簇索引

按字段特性分：

* 主键索引：必须唯一，且不能有NULL。主键索引也是聚簇索引
* 唯一索引：必须唯一，但允许有NULL
* 普通索引：不要求唯一，允许有NULL
* 前缀索引：指针对字符串的前几个字符建立索引，而不是用整个字段

### 优化

* 覆盖索引：如果要查询的所有字段在二级索引内全都包含，则不需要回表。比如二级索引是`(name)`，那么`SELECT id FROM ... WHERE name = ...`不会回表
* 索引下推：MySQL 5.6引入，对于联合索引，不符合最左匹配原则的条件也可以由引擎层判断而过滤，不用回表再交给server层判断条件。比如二级索引是`(a, b)`，执行`SELECT * FROM ... WHERE a > 1 AND b = 2`，查找索引时只能用`a > 1`的条件，但是`b`的数据也在索引里，引擎层可以判断`b`是否满足条件，而不用回表
* 提高区分度：建立联合索引时，把区分度大的字段排在前面，这样可以尽快排除大量数据。比如性别字段不适合排在靠前的位置，而UUID这样的字段适合排在靠前的位置
* 主键最好是自增的：使用自增主键，每次都是插入在最后一个节点的末尾，不需要移动数据，也不会导致页分裂
* 索引列最好是NOT NULL的：存在NULL值使优化器做选择时更加复杂，难以优化。因为NULL会使索引统计、值比较都更复杂
* 防止索引失效

索引失效的情况：

* 联合索引不符合最左匹配原则，或者字符串在开头使用了模糊匹配`LIKE '%...'`。因为联合索引和字符串都是从左到右比较的，比如建立`(a, b, c)`索引时，先使`a`有序，在`a`相同的时候再使`b`有序，在`a`、`b`相同的时候再使`c`有序。如果不符合最左匹配原则，就不能通过索引排除掉某些范围的数据，而只能全表扫描
* 在查询条件中对索引列做了函数计算、运算符计算、类型转换等操作。因为索引里存的是索引本身的值，而不是经过计算后的值。容易犯错的是隐式类型转换，MySQL在遇到字符串和数字比较时会把字符串转成数字。比如字符串列和整数比较`WHERE phone = 1300000001`会变成`WHERE CAST(phone AS signed int) = 1300000001`而使索引失效；但整数列和字符串比较则不会使索引失效
* `OR`条件中使用了没有索引的列
* 使用了否定条件，比如`!=`、`NOT IN`、`NOT EXISTS`

总之不能通过索引排除掉某些范围的数据，就会使索引失效

## 事务

### ACID

ACID是指事务的特性：

* 原子性（Atomicity）：一个事务中的操作，要么全部完成，要么全部不完成，不会结束在一个中间状态。如果事务在执行过程中出错，则会回滚到开始前的状态，就像这个事务从来没有执行过一样
* 一致性（Consistency）：事务操作前后，数据满足完整性约束。比如唯一键约束、外键约束
* 隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致
* 持久性（Durability）：事务一旦提交成功，对数据的修改就是永久的，即使系统故障也不会丢失

怎么保证ACID：

* 持久性通过redo log（重做日志）保证。提交事务在写入磁盘前先写日志，万一系统崩溃了也可以通过日志来恢复到事务完成的状态
* 原子性通过undo log（回滚日志）保证。修改数据之前先记录上一个版本的状态，需要回滚时就根据日志恢复到事务开始之前的状态
* 隔离性通过锁和MVCC（多版本并发控制）保证
* 一致性通过持久性 + 原子性 + 隔离性来保证

### 隔离级别

并发可能遇到的问题：

* 脏读：读到其他事务未提交的修改
* 不可重复读：在一个事务内多次读取同一个数据，前后两次读到的数据不一样
* 幻读：幻读是针对范围查询的，在一个事务内多次查询同一个条件的数据，前后两次读到的结果集数量不一样

事务的隔离级别：

* 读未提交（Read Uncommitted）：一个事务还没提交时，它的变更就能被其他事务看到
* 读已提交（Read Committed）：一个事务提交之后，它的变更才能被其他事务看到。可以防止脏读
* 可重复读（Repeatable Read）：一个事务执行过程中看到的数据，和它启动时看到的数据是一致的。这是MySQL默认的隔离级别。可以防止脏读、不可重复读。在MySQL中还可以防止大部分幻读问题
* 串行化（Serializable）：只读事务和写事务串行执行。可以防止脏读、不可重复读、幻读

MySQL如何实现这些隔离级别：

[参考](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)

* 读未提交：不使用锁和MVCC，直接读最新版数据
* 串行化：开启隐式事务的情况下把所有`SELECT`转换成`SELECT ... FOR SHARE`，也就是所有事务都用当前读，会加读写锁
* 可重复读：对快照读使用MVCC，在事务启动时创建Read View。对当前读使用记录锁、间隙锁、临键锁
* 读已提交：对快照读使用MVCC，在每条语句执行时创建Read View。对当前读使用记录锁，而间隙锁只用于检查外键、唯一键时

MySQL在可重复读级别怎么防止大部分幻读问题：

* 对于快照读，通过MVCC解决。如果有其他事务插入、删除数据，它的修改对当前事务是不可见的
* 对于当前读，通过间隙锁、临键锁解决。如果其他事务要插入数据，要先获得插入意图锁，但插入意图锁和间隙锁冲突，这个插入语句会被阻塞。同理如果要删除则要先获得记录锁

可重复读级别不能防止的幻读问题：当一个事务中混合了快照读和当前读就可能发生幻读。比如先`SELECT * FROM ... WHERE id > 100`，另一个事务插入了id = 200的记录并提交，然后本事务再`SELECT * FROM ... WHERE id > 100 FOR UPDATE`，这时就会多出前面插入的数据

### MVCC

MVCC是多版本并发控制，是用来提高并发性能的，它使只读的事务不会和写事务互相阻塞。MVCC是用于快照读的

* 快照读：不使用`FOR SHARE`、`FOR UPDATE`的`SELECT`语句。可能读到旧版的数据，即快照
* 当前读：使用`FOR SHARE`、`FOR UPDATE`的`SELECT`语句，以及`UPDATE`、`DELETE`这种修改数据的语句。读到的一定是最新数据，MySQL会加锁保证这一点

#### MVCC的实现

[参考](https://xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84)

Read View表示数据的一个快照版本，里面有4个重要字段：

* `m_ids`：创建Read View时还未提交的事务ID列表
* `min_trx_id`：`m_ids`中的最小值
* `max_trx_id`：创建Read View时数据库应该给下一个事务生成的ID，即`目前全局最大的事务ID + 1`
* `creator_trx_id`：创建该Read View的事务ID

通过这几个字段就可以判断某个事务ID做的变更在这个Read View是否可见：

* 如果事务ID < `min_trx_id`，说明创建Read View时这个事务已提交，可见
* 如果事务ID >= `max_trx_id`，说明创建Read View时这个事务还没有创建，不可见
* 如果事务ID在`[min_trx_id, max_trx_id)`范围内，则还需要判断是否在`m_ids`中
    * 如果事务ID在`m_ids`中，且不是`creator_trx_id`，说明创建Read View时这个事务还没有提交，不可见
    * 如果事务ID不在`m_ids`中，说明创建Read View时这个事务已提交，可见

另外聚簇索引中每个记录行有2个隐藏列：

* `trx_id`：写入这个记录的事务ID
* `roll_pointer`：指向undo log中上一个版本的记录，上一个版本的记录中的`roll_pointer`指向上上个版本，这样形成一个版本链

对每一行进行快照读时，先判断`trx_id`对该Read View是否可见，如果不可见再判断上个版本是否可见，一直寻找到某个可见版本，或者跳过该记录行

### 锁

参考：

* [MySQL有哪些锁](https://xiaolincoding.com/mysql/lock/mysql_lock.html)
* [MySQL是怎么加锁的](https://xiaolincoding.com/mysql/lock/how_to_lock.html)
* [官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)

#### 分类

* 表级锁
    * 表锁：共享表锁`LOCK TABLES ... READ`，独占表锁`LOCK TABLES ... WRITE`。表锁和行级锁会冲突，一般不使用，因为粒度太大了
    * 意向锁（Intention Lock）：共享意向锁指定事务想要在某些行上加共享锁，独占意向锁指定事务想要在某些行上加独占锁。意向锁之间不会冲突，和行级锁也不会冲突。意向锁是为了方便查找表里是否有记录被加锁，否则只能遍历锁来查找
    * 元数据锁（Metadata Lock）：进行增删改查操作时自动加共享MDL锁，对表结构进行修改时自动加独占MDL锁
    * AUTO-INC锁：插入记录用到自增变量（AUTO_INCREMENT）时加锁
* 行级锁
    * 记录锁（Record Lock）：锁定一条记录（索引）
    * 间隙锁（Gap Lock）：锁定记录（索引）之间的间隙，是一个开区间。间隙锁虽然分共享锁和独占锁，但是它们功能相同且不会冲突，因为它只是用来防止幻读的
    * 临键锁（Next-Key Lock）：等于间隙锁 + 记录锁，是一个左开右闭区间。因为间隙锁 + 记录锁的情况太常见了，遇到这种情况就会把两个锁合并成一个临键锁
    * 插入意向锁（Insert Intention Lock）：一种特殊的间隙锁，插入记录之前要先加插入意向锁。插入意向锁会和间隙锁、临键锁冲突。它是用来防止幻读的

#### 加锁方法

情况太多了，具体的看参考链接，这里只总结一些规则

* 锁是加在索引上的，如果没有找到对应的索引就会变成间隙锁
* 如果搜索的是主键索引则在主键索引上加锁；如果搜索的是二级索引则在二级索引上加锁，并且在主键索引上加记录锁
* 锁的范围尽量小，但要覆盖搜索条件
* 相邻的间隙锁、记录锁会变成一个临键锁（或者说优先上临键锁，但是有时边界会退化成记录锁和间隙锁）
* 索引的头部和末尾是负无穷大和正无穷大伪记录，伪记录也可以加锁

MySQL是一边扫描索引一边加锁的，如果查询条件没用到索引，则需要扫描全表，这样会对每一条记录加上临键锁，相当于锁全表

#### 死锁

一种死锁的情况：

1. 假设存在id = 1和10的记录
2. 事务A执行`UPDATE ... WHERE id = 2`，更新了0行，获得了`(1, 10)`的独占间隙锁
3. 事务B执行`UPDATE ... WHERE id = 3`，更新了0行，获得了`(1, 10)`的独占间隙锁
4. 事务A想插入id = 2的记录，需要先加`(1, 10)`的插入意向锁，但是这时事务B持有间隙锁，所以阻塞
5. 事务B想插入id = 3的记录，需要先加`(1, 10)`的插入意向锁，但是这时事务A持有间隙锁，所以阻塞

如何避免死锁：

* 设置事务等待锁的超时时间，当事务获取锁超时时，会回滚
* 开启主动死锁检测，检测到死锁时会回滚其中一个事务
* 将事务隔离级别设置为读已提交，这样不会加间隙锁，但是会有不可重复读、幻读问题

## 优化数据库

当数据量太大了，就会出现查询慢的问题。这时可以采用分库分表、读写分离等方式减少数据库负载

### 分库分表

分库是为了解决并发量太大的问题，因为单机的磁盘带宽、网络带宽、连接数、内存缓存都是有限的，分成多个结点的库可以减少每个结点的负载

分表是为了解决数据量太大的问题，数据量越大磁盘IO次数就越多。分表方法有垂直分表、水平分表：

* 垂直分表是按照业务、冷热数据等属性把不同字段拆分到不同的表。拆分后每行数据大小变小了，表中的页数会减少，磁盘IO次数也会减少
* 水平分表是按照主键的哈希把记录拆分到不同的表。拆分后B+树的高度变小，磁盘IO次数也会减少

缺点：事务、范围查询、数据聚合、join查询比较麻烦，需要应用层做特殊处理

适合分表的情况：数据之间没有关系，基本是按主键查找的；不需要复杂的事务、join查询

### 读写分离

使用主从复制把主库的数据同步到从库，然后主库负责写的事务，从库负责只读的事务。读写分离也是为了提高并发性能的，使只读事务和写的事务互不影响。读写分离适用于读多写少的情况

缺点：数据不一致，主库数据同步到从库需要时间，如果要求强一致性则不能用

# Redis

## 特点

## 数据类型

## 缓存

### 淘汰策略

### 缓存一致性

### 缓存穿透/雪崩/击穿

## 事务

## 持久化

## 集群

### 主从模式

### 哨兵模式

### 集群模式
