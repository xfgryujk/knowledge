自我介绍
离职原因

介绍下有代表性、投入比较大、产出比较好的功能
团队大概有多大
你在团队中是什么定位

排行榜的需求背景、难点、怎么解决的
    我们排行榜是分为两种，一种是全量的，就是上报的玩家全部都要保存起来，另一种是只保存前几百这种。全量的是用了Redis的Zset去实现的。前几百这种我们是直接用一个map存在我们的进程内存里面

你们服务器大概什么样的架构
你们哪部分是可以横向扩展的，哪些是不可以的
    大部分都可以吧，像gateserver、gameserver都是可以直接扩展的，直接部署多台都可以
你做的排行榜大概是在哪个部分，什么样的业务
    我们排行榜是做在单独一服务器上的，就是nodeserver后面再连一个rankserver，就是排行榜服务器
你们玩家是直连gate，gate和game是有一个间接的关系对吧
nodeserver和gameserver有什么区别
    nodeserver主要是负责消息的路由嘛，nodeserver就是把服务器的各个进程连接起来
如果node在做路由的话，gate在做什么事情呢，gate只是用来做登录是吧
    gate只是负责和玩家连接的嘛，nodeserver负责和我们内部的服务器连接
你的nodeserver要做路由的话，它是要连接到所有的game吗
    对，所有服务器都会连接，除了gateserver都会连接
mailserver、snsserver，这些和gameserver有什么关系、区别
    gameserver负责玩家自身的逻辑嘛，其他的server不负责玩家逻辑，或者就是负责多个玩家的逻辑。比如snsserver会负责好友的关系维护
你的排行榜是单独抽离出来一个服务是吧
介绍一下难点，或者技术指标，或者需要注意的点
    rankserver的话它是单独做在一个服务器上的，gameserver如果想要它的数据，就需要通过请求去获取它的数据。这是一个异步的过程，可能gameserver这边会开一个协程去处理这个请求。就是发起一个请求就是创建一个协程，然后等待这个请求返回，再唤醒我的协程继续往下走
    像协程的话，我们之前用协程遇到一个问题，这个请求返回了唤醒了我们的协程，但是玩家对象销毁掉了，所以你的协程里面用到了玩家对象的话就会出现内存错误，导致我们的进程崩溃
你这里在gameserver的逻辑，怎么和rankserver打交道呢，你们内部有什么封装吗，直接发协议还是用RPC之类的方式
    我们是直接发协议的，就发给nodeserver一个协议，然后让nodeserver转发给rankserver这样
你们每一个新的调用都要自己写一个新的协议吗，还是有其他方式
    都是要写协议啊，就是每新加一条协议就要改一下proto，定义新的proto嘛
所以你做这个rankserver其中一个工作就是要定义一堆proto来给其他人调用对吧
你们日常开发业务是用什么语言
    全都是C++的

你刚刚提到你用到一些协程来做一些开发工作，你怎么理解这件事情呢，用协程或不用协程有什么收益或风险
    协程主要是简化我们异步请求的写法吧，因为它可以把异步的逻辑写得跟同步差不多。协程有一个好处就是上下文管理比较方便，因为如果不用协程的话，可能要把上下文单独存在一个map里面，或者是把上下文存到消息里面，让服务器处理完之后把上下文带上来，再返回给我们。用协程的话就可以直接把上下文存在局部变量里面吧，这个会比较方便
那会有一些什么坑点或者是负向的问题
    比如刚才我说那个，因为这其实还是一个异步的操作，然后协程唤醒之后它可能上下文就会变了，比如之前可能玩家对象是有效的，但唤醒协程之后玩家对象就被销毁了，这时候可能会出现内存错误什么的
那你本来的收益是可以方便地保存上下文，现在用了它又变成了上下文可能发生变化，还需要额外做一次检查
    所以就是有一些权衡吧，总体来说还是收益比较高
你实际做的过程中，上下文失效带来的问题有在线上暴露过吗，还是开发中就处理掉了
    基本上是开发时发现的，因为这种内存错误，Linux它会生成一个coredump嘛，然后我们去查这个coredump的时候就会发现，这个时候玩家对象销毁掉了

那你写的业务线程挂过吗
大概什么问题啊，能不能稍微举两个点
    我举个例，还是比较简单的问题。我们有时候需要删除一个map里面的一些东西，这时候有两种写法，一种是先把要删除的key存到一个vector里面，迭代完这个map然后再迭代一遍这个key去删除；另一种就是直接一边迭代这个map一边删除，因为可以用迭代器去一边迭代一边删除（被打断）
你一边迭代一遍删除一定是可以工作的吗
    因为删除之后会给你返回一个新的迭代器，可以用这种方式去一边迭代一边删除
    之前我是用了这种方式嘛，然后就出现问题了，因为循环里面可能有多个分支，可能一个分支里面处理了迭代器++，然后另一个分支没有处理，这时候可能造成一个死循环。所以后来我都是改成先存到一个vector里面，然后再迭代一遍再去删除
有没有什么状况不用这种提前缓存的方式也能够支持循环中删除呢
    map有个erase方法，就是删除嘛，erase的返回值也是一个迭代器，它是返回下一个迭代器的，所以可以一边迭代，当删除的时候就可以把迭代器赋值成下一个迭代器，然后continue，这样就可以一边迭代一边删除
    但我刚才说的就因为我用这种方法，然后有一些分支没有注意到，就会出现问题，所以后来我都是用那种更加保险的方法

你做这个排行榜大概花了多长时间
    这个比较早了，可能大概两周多点吧
你把它抓出来是觉得哪部分做得不错
    因为这个是涉及到不同的进程吧，然后rank是比较全局的服务，它不是局限于某一个玩家之类的吧
对于这个情况会有一些性能的风险吗。我举个例子啊，可能你们既然这么写了那线上跑是没问题的，假如说这个产品的用户量扩大10倍，扩大100倍吧，对于现有架构还OK吗。对于排行榜，假如用户量增加了100倍，现有的架构能够很好地支持吗
    因为它其实是一个单点的，可能负载支撑不了这么高。其实可以给排行榜去分片处理，分成多个排行榜服，每个服按排行榜ID去哈希，每个服去负责一部分的排行榜
那假如单个服的数据量发生了很大的变化
    可能可以做一些读写分离吧，读的时候可以在gameserver给排行榜做一个缓存，读的时候就直接读这个缓存，写的时候还是请求到rankserver这样
这里面涉及到几个点，比如排行榜的构造是否仍然可以支持更大规模，因为维护排行榜也是有开销的，另外数据的分发和同步对用户而言是否OK
    因为其实业务上并不需要一个实时的排行榜，所以缓存一下，玩家可能看到的时间会晚一点，其实还可以
那你这里的缓存大概是什么逻辑
    比如gameserver里面可以做一个全局的缓存，ganmserver要拉排行榜的时候先看一下有没有缓存，如果有缓存就直接返回，如果没有缓存再去rankserver请求一下，然后把它缓存到gameserver内部的全局变量里面
那像构造这个数据呢，比如更新排行榜变得很频繁，会不会给更新数据带来一些压力
    更新的话，像是前几百的排行榜，其实gameserver可以缓存一个排行榜上面最低分数吧。如果发现玩家的分数超过这个最低分数，才去给他上报一下，如果没有超过就不上报了
这部分有没有什么优化空间，比如大量用户都在更新这个排行榜信息，你的进程可能扛不住
    （你这抛开具体业务场景，光谈请求量无限上涨，有点耍流氓吧）
    不是啊，就是前几百的，因为实际上能达到前几百的人数还是很少的，所以倒不会有很高的请求量
假如遇到这个业务场景，请求量很大怎么办，大量用户在同时更新战力，比如就做一个战力排行榜吧，这个单进程有点扛不住了
    或者说按分数段分成不同的排行榜服，不同的服务器会负责一个分数段
除了这种思路还有其他思路吗，这是一种解法
    （想了半天，实在想不出了。其实这里可以扯一下限流、降级、熔断什么的，或者改成非实时的排行榜）
    基本上就是分片或者读写分离了吧

你后面还有一段在做（上家另一个项目），它和（上家项目）差别大吗，技术栈等各种方面
    其实它们架构都是这样的，技术栈也是一样的，都是C++
引擎也是同一套吗，服务端的
那你在这边的工作和那边的工作差别大吗，还是基本做类似的内容
    我调到（上家另一个项目）主要是做内部工具了
有哪些工具啊，能稍微列举给我吗
    （被打断）
首先问一下你是什么时候被调到（上家另一个项目）的
那还挺早的，请继续
    我做的工具还是比较杂的，它包括服务器的构建脚本，就是Jenkins上面有个自动化任务，还有策划的数值导表啊，还有我做的一个B/S架构的服务器工具箱。它是可以供运营、策划、QA，方便他们去操作服务器的。包括拷贝玩家账号、修改服务器时间、发送GM命令、修改服务器配置，还有模拟抽卡等等功能
这个跟你之前写业务代码区别是基本在业务外围是吧，有多少人在做这个事情，还是只有你一人
    我之外还有两个人吧，但主要还是我做的
你们这个团队有多大
听起来你们服务器人还算多啊，但这部分工作只有你一个在做，其他人都做业务开发
    因为我们服务器这边招人主要还是招的C++服务器吧，因为都是写C++的，然后会web技术栈的会比较少。因为我们做这个工具是需要会web后端，包括前端要写JS啊，前端的一些框架，包括HTML这些都要会啊。然后刚好我就会，我大学时是自己学了这些技术嘛，但其他人他们是C++招进来的，可能就不会这些
我看到你们用Flask，还在参考FastAPI，干嘛不直接用FastAPI呢，还要去参考
    因为这个做得也比较早了，它是3年多以前去做的
做这个对你个人成长帮助大吗，还是不如之前成长多一些
    有部分吧，但感觉没有之前那么大。因为做工具的话会接触到比较杂的一些技术，包括一些云服务，要接触阿里云、AWS，包括他们的SDK、OSS、AWS的S3存储。然后要和很多不同职能的人去打交道，包括运营、策划、QA、运维，包括服务器自己有什么需求，他们有什么需求会反馈给我，然后提一些功能优化或者迭代之类的
你们Jenkins上部署的job或者业务流程有需要用什么仓库代码去管理吗，或者需要做什么备份的
    我们用的都是git嘛，IT那边会维护一个服务器，IT那边去备份
这个备份是什么方法呢，是将Jenkins的配置文件提交到git吗
    因为我接手之后Jenkins主要是用流水线脚本去写的，可以把流水线给提交到git里面
也就是流水线里面写了脚本的git路径，然后自己去拉是吧。那像Jenkins自身的配置呢，假如Jenkins挂了，或者服务器坏了怎么办
    （其实硬盘用了RAID1，可以扯一下）
    这个倒没考虑过
对于这种自动化的CI/CD工具有去了解过其他的解决方案吗，有什么优缺点之类的
    还有一个TeamCity啊，它好像是支持项目的模板吧，就是开多个类似的任务会比较方便。但Jenkins就是比较简单，Jenkins上手成本会比较低吧，它本身是开源免费的

前面你在做游戏开发还有什么点可以聊一下吗。你做过花你时间最多的业务是什么
    有一个周报的功能啊，就是统计每一周玩家获得了什么成就啊，什么名次啊，或者获得多少货币之类吧
    因为这个数据可能涉及到很多模块啊，它不只是在玩家自己的数据上面，可能涉及到很多进程，或者很多个活动，然后它们的结算时间又不一样
    所以我最后是做成了，玩家上线的时候或者临近结算的时候开一个定时器，然后在回调函数里去结算（被打断）
插桩吗。就收集和整合吧，收集可能是在日常业务中去收集，怎么整合呢
    收集的话可能在活动里面加一些代码，让它回调，然后收集这些数据存到Redis里面，就存到一个地方让我之后可以去获取。当玩家上线或者临近结算的时候，可以去异步地获取这个数据，然后存到玩家自己的数据里面
这里面会不会存在一些问题，比如你提到两次，上线的时候和临近结算的时候，这两个点会不会存在风险
    你是说如果这个过程出了什么错误可能让玩家登录失败吗
假如这个游戏异常火爆，某一天开新服，玩家密集登录，会不会带来压力
    因为我还是做成异步的操作，其实不会阻塞玩家登录什么的
不阻塞是一回事，但是有这么多计算量，会不会导致结算成本会消耗不过来
    我个人感觉计算量也没有这么大，因为结算的时候去存一个数据吧，然后上线的时候再去拉这个数据，拉数据我感觉还是轻量级的
我看你们是Redis和MySQL一起用，那什么时候存Redis什么时候存MySQL
    Redis的话我们认为可以存储一些不太可靠的数据，因为Redis可能它挂了会丢一些数据
    MySQL我们是存储一些重要的，必须要可靠的数据
那在你看来周报的数据是可以丢弃的吗
    因为它主要还是一个类似于统计的功能吧
用户如果说我这个周报为什么没了，在你们看来是可以接受的
    是，因为这还是比较边缘的功能
那为什么不放在MySQL呢，放在Redis有什么好处吗，这也不是一个实时性很高，或者性能压力很大的系统
    就是考虑Redis比较快吧，而且Redis本身比较简单
这不是有点矛盾吗，因为这不是一个实时的系统，对性能不敏感的系统，为什么还要追求它快
    因为玩家数这么多，可能每一周上线的人会比较多吧，每一周统计的数量会比较多
这个多会带来什么问题
    存储的时候会比较慢吧，因为数据量会比较大
这个慢会带来什么问题
还是没有细想这一层的原因
你们内部是有什么指导原则吗，什么时候数据会存哪
    因为这个周报数据它会有一些给其他用户去看的数据，然后我们本身也是有一个给其他用户去看的，就是玩家名片这样的东西，实际上会有一些数据存储在玩家名片里面，它本身就是存储在Redis里面，所以正好就用了
    （其实这才是主要原因，刚才可以早说的）
延续这个结构去使用开发了

你们这游戏里面有交易系统吗
假如让你做一个交易系统你会怎么做啊
有用过其他游戏里面的交易系统吗
我给你举个例子，比如我想进行游戏交易，我会发一个交易申请，你只要点同意那么会打开一个交易界面。有上下两个物品栏，我可以摆我的东西，你可以摆你的东西，可以看到对方摆的物件。都摆完以后双方点击锁定，大家都认可这个结果后就可以交易，双方点交易那么物品交换。这是个标准的交易流程吧。过程中有任何一个人后悔他可以取消交易，过程结束。如果让你在这个架构里面实现这个系统，你会怎么做
    因为交易是涉及到两个玩家的数据嘛，这种情况我们会做在一个单独的服务器上，比如做在snsserver里面，这里面会有一个交易的服务
    然后每个玩家可能在不同的gameserver上面，玩家往里面放东西就是，可能先扣东西，然后生成一条消息啊，把这个消息发到snsserver上面（被打断）
为什么要先扣啊
    因为先要保证这个东西不能被其他的事务给改写吧，要先把这个东西锁定下来，类似于这样的功能
    然后本身会记一个标记，生成一条消息，把这条消息发到snsserver这里。snsserver这里会维护一个交易的状态，就是交易双方有什么物品，把这个物品添加进去
    交易双方都同意交易之后，snsserver把这个消息再发回到双方的gameserver。这时候玩家本身会记一个标记，就是把刚才锁定的物品，给真实地扣除掉了，并且加上对方的物品（被打断）
这个过程中有哪些点需要特别考虑，或者有哪些边界条件要处理吧
    因为这个是涉及到不同的server嘛，它会涉及到消息的交互，消息可能会丢失。所以我们每一步需要一个，比如先打一个标记再发消息，然后消息需要一个确认机制，如果没有收到确认，这时需要重发这样的功能。包括如果重发了很多次都失败啊，它就是会失败，这时候服务器挂掉了之类的。这时候可以根据之前的标记再把物品还原回来，回退吧
你们之前的业务也是这样的流程吗，包括要加重试和确认
    像我们的mailserver是有重试的，因为mailserver会存储你没有处理过的消息的列表吧。像是一些离线的消息，重要的比如结算消息，会存储到mailserver里面，然后玩家上线的时候去mailserver拉一下，哪一些消息没有结算过的给它结算
    当然玩家本身会存一个已经结算的消息列表，就是用来防止重复结算的
这里面你提到的有一个物品锁，除了这种方案有什么其他更好的方法
    （想半天没想到）
你们在做的时候有没有类似的需求啊，需要对物品有锁定的操作
    我们这边没有交易的
你觉得这个物品锁的设计主要是解决哪些异常状况
    就是我要先禁止其他的事务去操作这个物品吧，因为你可能把物品发到另一个server了，但是这时候本身另一个事务又可能消耗掉这个物品，那相当于你有两份这个物品了，这个是不合理的
那比如像交易成功，一边扣一边加的过程中会不会存在什么状况需要考虑的
    就是中途丢包之类的吧，所以需要一个重试和确认的机制
    为了防止这个事务中途丢掉啊，可能会把这个事务给写入到数据库。比如这个事务就是A扣了什么加上什么，B扣了什么加上什么。这个事务本身也是需要上线的时候拉一下有哪些没完成的事务，给它一个补偿的机制这样
你提到的事务是数据库提供的事务机制，还是你自己封装一个机制，让它具备事务的特征之类的
    我们自己封装的嘛
你自己有封装过类似的系统吗
    这倒没有。就是我们mailserver是这么设计的吗
刚刚这个交易里面让你来设计这个事务，你会怎么实现这个机制
    它相当于是两条操作，就是A扣了什么加上什么，B扣了什么加上什么。这两条的话应该是在同一个数据库的事务里面添加进去的（被打断）
你这里面数据库事务的前提是物品数据全部存在数据库里面才存在这个事务吧
    不啊，就是可能存在snsserver，交易双方会去确认嘛，当你确认完成后生成一条这样的事务或者说消息，把它存到数据库里面
你怎么理解事务这个概念呢，听起来好像db也在用这个东西，业务也在用这个东西，它们怎么配合去完成这样的工作呢
    我们自己实现的事务的话，我理解它是一个不可分割的过程，原子性嘛，要么全部完成，要么全部回滚掉
事实上它会有多个异步的步骤嘛，怎么达到你的预期呢
    实际上我们最后是靠数据库的事务性来实现交易的事务性，因为最后是通过一个数据库事务去把这一堆步骤给存到数据库里面
对于数据库的事务而言，你给它一个完整的事务，数据库能够保证它整体完成或者整体失败，这是db完成的。那db完成这个过程中它是一个黑盒逻辑，你怎么跟业务关联呢，业务还在db之外
或者你能描述在这个交易过程中怎么利用db来完成一次交易的流程吗，或者事务的流程
    比如刚才流程到双方都确认了嘛，就是发到snsserver了，它会向数据库写入这样一条事务，就是A扣了什么加什么，B扣了什么加什么，写入成功后，再向双方的gameserver回这样的消息
你的db可以直接完成物品的加减是吗
    （头疼，他还是没明白。要不直接说有一张未完成的消息表，主键是消息ID，存了序列化的消息）
    没有，我们物品都是存在玩家身上的，就是存在gameserver里面
    不是，我db存的是一个消息啊，它不是直接存的物品。比如我db存一个消息嘛，你给它一个事务ID（又又又被打断）
我举个例子啊，你gameserver里面有一个业务逻辑代码是用来加物品的，还有一个代码是用来删物品的，这是两个接口对吧，那整个事务里面怎么调这两个接口呢，什么顺序什么规则去调，什么时候加什么时候减呢
    我会给这个事务单独一条消息吧，单独一个proto（又又又被打断）
我们先明确一下啊，这个事务是你自己设计的机制叫事务呢，还是db的事务机制
    我们自己设计的机制，叫做事务
    这个消息我单独加了一条proto嘛，这个消息里面它存储了我要扣什么东西，我要加什么东西。当我处理这个消息的时候，扣和加肯定是在同一条消息处理里面去完成的，可以保证它的原子性，而且处理完这条事务要给它打一个标记（被打断）
这里有一个点在于，加和减的行为可能发生在两个不同的gameserver上吧，因为玩家不一定在一起。也就是你这段代码可能在不同的进程执行，怎么保证它的事务性
    两个玩家可以分别去执行啊，因为我最后写到db里面的是两条消息，一个发给A的，一个发给B的。两条消息里面各自存储了，各自要扣什么，各自要加什么
OK，这个点先聊到这个吧

你目前的工作状态是什么样
为什么离职了，一般不都是先找下家再离职吗
假如在工作中可能有两类工作，一类对你而言是常规的业务开发，一类是比较有挑战的，需要动脑筋花大量时间去研究的，这两类工作能接受的比例大概是什么样
你对新的工作内容只是做游戏开发就好，还是有其他想法，有更明确的希望
平时有做技术上的学习、积累、研究吗，工作之中
期望薪资
现在是多少

反问
    之前面试官说你们更新的时候不会采用重启进程的方式，那么你们是怎么做到不停机更新的呢
        这个属于技术细节啊，如果你感兴趣的话可以加入我们细聊。这种方法有很多，在网易已经是基本操作了。我优先回答面试相关的问题吧
        如果你是对技术细节感兴趣，好奇怎么做，那我相信如果你有机会加入到这边，你这个好奇心会得到充分满足。网易做了这么多年这方面积累是很多的，很多同学加入之后首先会面对一个信息爆炸的问题。类似这样问题的技术方案，解决方案是非常多的，光是自研引擎我们也不止一款，技术方案也不止一个，甚至各个项目需求都有差异，多样性还是和其他东西有差别的
    你们会期望团队里的成员，比较看重什么技能吧，比如网络、多线程、架构、业务之类的
        我们是个多样化的文化，更期望每个团队有自己的风格和特点，它不是一个统一定的规章制度，希望你们先看什么后看什么。但如果真要去讲各个团队部门或者公司的统一价值观的话，可能我们更期望看重每个同学个人能力，这个更重要。因为技术也好经验也好它都是一时的，我们应对方案是没有标准解的，新技术也是层出不穷的，如果有一天我们变成了靠经验吃饭，那基本上就变成了一个流水线的工人吧，可以按件计费了。而对我们而言最有价值的点是在未知的状况、未知的环境、未知的市场，做得比别人更好，这个时候考验更多的是个人能力。所以越是准备好的同学可能给的成长空间越大，我们是这样的工作方式，并不会说专门谁去只玩什么技术栈，谁去做什么，更多是能者多劳


------
这次面试官是引擎组的大佬，更多关注架构方面吧
中间有些地方没有来得及表述清楚就被打断了，有点难受
根据之前开放式问题的经验这次多说了很多话，看来策略是对的
几小时后收到HR面邀请
