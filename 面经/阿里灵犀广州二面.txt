自我介绍
为什么调去做工具
离职原因
为什么不先内部转岗
有机会的话是优先选择内部还是先出来看
有意愿到广州工作吗
优先找上海还是广州

介绍一下（上家项目）的服务器架构
nodeserver看起来是一个中转吧，为什么要中转，为什么gameserver不直接访问dbserver
    所有服务器直连的话相当于是一个网状的结构，有一个中心服务器的话相当于是一个星型的结构，星型的连接数比网状的少很多
    而且nodeserver本身会管理一些路由的信息，因为我们nodeserver会存储某一个UID它登录在哪一台gameserver上面。那如果是所有服务器直连的话，比如像发一个消息给某一个UID，要自己去存储这个路由的信息。这个路由的信息可能会非常庞大，因为在线玩家数可能会很多，所以如果每一台服务器都去存这个那就不好了
Redis是不是已经记录了UID登录到哪个gameserver了，所以在nodeserver里要再记吗
    访问Redis还要一次RPC，这肯定比直接访问内存要慢很多
但是比如对于mailserver，要访问gameserver也要通过一次RPC，nodeserver去取，它跟到Redis去RPC不是一样的吗
    nodeserver主要还是负责消息的路由吧，Redis它有另外的作用。Redis存了一个UID的登录信息，它是用来防止多登的吧。因为gameserver登录之后会去Redis写一下UID登录到的gameserver，这个过程我们用了一个CAS原子操作，就是用来防止多登的。如果写入失败的话就判定它是在另一台gameserver登录上了，这个时候会给它登录失败
下面这个图是什么意思
    是我们gameserver的线程模型
深入讲一下
    gameserver里面会有多个网络线程和多个逻辑线程嘛。网络线程就是负责收发包的，收包之后给它解析出一个消息，消息头里面会带有UID。我们会根据UID把这个消息给分发到某一个逻辑线程，就是按照UID的哈希去分。所以某一个玩家一定会分配到某一个逻辑线程上，对于单个玩家来讲，它的逻辑就是单线程去运行的，也不会有什么多线程的问题

你刚才说避免多登的问题，用Redis来记录这个玩家登录到哪个gameserver，那这是一把锁对不对，这个锁你们有设置过期时间吗
    没有过期时间
那比如说有段时间登录不了怎么办，登出时候报错了，没有从Redis里把锁给清掉，或者gameserver宕机了，哪玩家岂不是永远登录不了
    我们还是根据Redis里面的信息把它发到某一个gameserver上，如果gameserver这时候没有它登录的消息的话，还是继续在这台gameserver上登录，这个不会有问题。如果gameserver宕机了，Redis里面存的这个gameserver发不过去了，那我们会根据一致性哈希再给它发到另一台gameserver上
你的信息不是已经在Redis里了吗
    但是因为这个时候gameserver宕机了，你没法发给Redis里面那一台gameserver，你要找另一台去发
那Redis里这条记录怎么办，这条记录是要清除吗
    就可以被覆盖啊。因为原来那台gameserver宕机了，那你的用户也就算是下线了，所以在新的服务器登录上，那是没问题的
那怎么判断gameserver宕了，也可能是网络抖动对不对
    我们会给一个超时时间吧，就是断线超过30秒可能判定它宕机了。因为服务器都是走的内网去连接的，一般来说不可能超过30秒还连接不上
Redis记录这个锁是为了防止玩家登录到多个节点，那怎么从一台gameserver主动下线，然后再登录到另一台gameserver呢
    下线的时候就是把Redis里的信息给清除掉了啊
你们gameserver如何支持在线扩容
    就直接启动几台新的gameserver。因为gateserver它会根据一致性哈希去选择gameserver，如果是新登录上的就会登录上新的gameserver
为什么用一致性哈希呢，为了解决什么问题
    也是跟这个多登有关的吧，因为Redis本身有可能会宕机。假如说Redis宕机了，因为我根据一致性哈希去选择gameserver，我大概率还是选到原来的gameserver，就尽量减少它在不同的gameserver上登录的概率
就是Redis宕机的时候你们还是可以登录吗
    Redis宕机的时候可能会丢一段时间的数据吧，丢几秒钟的数据
也就是即便Redis宕机了，你用一致性哈希还是能正确找到之前的gameserver是吗
一旦这个时候有gameserver也宕机的话就会有问题
    对，但毕竟这个是小概率时间，因为Redis和gameserver全都宕机了，概率还是比较小
你首先用一致性哈希选择一个gameserver，然后记录到Redis里，之后都通过这个Redis去查
你们Redis集群是怎么搭建的，有没有用Redlock这个算法
    没用，我们没有需要分布式锁的需求吧
那你们Redis集群是怎么选的
    就是Redis Cluster啊
是一个主备结构吗，还是其他结构
    分片的

你们有战斗服吗
    （上家项目）的话战斗都是在客户端去做的，然后联机的话我们会有单独的一个联机服务器
那怎么防止玩家作弊呢
    我们主要还是玩家上报结果的时候会有加密还有一些统计信息吧，我们运营会根据这个统计信息做一些反作弊的处理。另外就是我们服务器会动态分发一些脚本给客户端执行，这个脚本里面会检测客户端是不是加载了什么第三方模块，可能用来作弊的模块之类的
就是你们战斗服务器完全不管，也不校验结果
    （上家项目）是这样的，（上家另一个项目）它是有校验的
它是怎么校验的
    它会有一个battleserver，就单独一个战斗校验服务器嘛。battleserver它代码是和客户端共享的，客户端会有一个C#代码，服务器这边跑.NET，就是去跑客户端代码
就完整再跑一遍是吗。它怎么保证两端跑的结果是一致的呢
    因为代码都同一套啊，玩家的操作序列，包括随机数种子、初始状态什么的都会发过来
代码同一套还不够，还有哪些因素会影响这个一致性
    比如说浮点数吧，我们就不用浮点数了，就改成一个整数
还有其他的吗
    （没想到）
比如说排序算法会不会有影响
    你是说排序里面可能会有一些随机化吗
不是啊，排序应该没有随机。一般的排序算法的话，什么情况下会导致两边算的结果不一致
    有那个不稳定的排序算法，比如快排就不稳定
不稳定指的是什么
    就同一个值排序时候他们的顺序会不会变
还有另外一种，哈希表呢，对哈希表遍历一遍，顺序一定一致吗
    主要依赖于C#的实现吧
你觉得它的哈希表是怎么实现的
    这个不太清楚，可能会有随机化吧，因为我听说Go那边哈希表是随机化的

你们这些公共服，比如nodeserver和mailserver，这些线上动态扩容的话可能吗
    这些基本上是无状态的，随便扩容吧
有没有那种一些全局的，比如公会服，还有全局的活动
    有一个，其实还是无状态的，我们这种状态是存在数据库里面

你这个功能开关的功能，在这个架构下是怎么实现的，因为节点很多，如何保证每个节点上都有这个功能
    我们这个功能开关是数据库里面会写一个配置吧，就是哪些功能会关掉，它们参数是什么。然后每个服务器会定时去数据拉一些配置
等于是你们直接操作数据库是吗
    就定时去拉吧

你们排行榜是用Redis实现的，那你了解Redis用什么来实现的吗
    我们用了Redis那个Zset数据类型，然后它底层是一个跳表嘛。跳表它是在原来双向链表的基础上加了很多层的索引层，索引层它的结点数会比较少，所以查找时候就是从最高层开始查，按照类似于二分查找的算法去查找
那跳表的构建过程，比如从零开始插入数据，怎么把多层链表构建出来，如何保证每一层的节点数都相对均匀
    Redis的算法是每插入一个节点之后会有1/4的概率生成上一层的结点，生成完之后又有1/4的概率去生成上上层的结点

你还做过一些活动，能不能讲一下活动框架是怎么实际的，如何去扩展新的活动，然后还有活动重开的话怎么做
    每个活动它的需求都不一样吧。总的来说的话，会有一个排期表，就是从什么时间到什么时间会开什么活动。然后我们活动会有它自己的协议，我们在获取活动信息的时候会去判断一下，如果到时间然后你还没开这个活动，这时候就给它初始化一下
    所以基本上是客户端来拉的时候才去初始化一下，然后客户端登录的时候会去拉一下排期表，就是最近有什么活动吧。到了那个时间用户可以点进这个活动页面，然后到了活动页面就去拉一下活动信息，我们这边就给它初始化一下这个活动
是客户端去拉的时候才会初始化吗，有没有一些全服活动，你这个听起来像单人的活动
    像全服活动的话，我们是把状态存在一台服务器上。这台服务器会用定时器，就是最近活动什么时候开始，设置一个定时器，到那个时间再去初始化这个状态
我怎么方便地去增加一个新的活动，从这个活动框架的话
    这种活动就是一个排期表，还有一个具体活动的配置表。增加一个活动的话其实就是，把以前的活动配置给复制一遍，然后再去增加一个排期。活动会有对应的活动ID嘛，就这个排期里面我要开这个活动ID，就可以了
那活动要重开呢，不是开两个
    重开的话也就是复制前面那个活动配置，然后把活动ID给改一下。因为活动ID的话它可能会存储以前旧的活动的状态，所以不能用和原来一样的活动ID，这时候要给它换一个
那活动的存盘大概是怎么设计的
    我们大部分活动还是玩家自己的，就跟着玩家数据一起去存。我们玩家数据会在gameserver里面有一个缓存嘛，然后它采用的是一个定期存盘加上即时存盘的机制。因为改了什么重要的数据，比如充值或者抽卡，它会立即触发一次存盘

看你写了一些协议频率限制、死循环检测。先讲一下这个协议频率限制，你说用到令牌桶算法，具体讲一下
    令牌桶算法其实有点像我们游戏中的体力恢复算法，就是会有一个桶，它会以固定的速率往里面添加令牌，如果这个桶满了就不再添加了。然后请求要从桶里面获取一个令牌才能继续执行，如果没有获取到令牌就说明这个请求被限流了，就拒绝掉这一次请求
那拒绝请求对玩家的操作是不是体验很差
    我们会事先统计一下，按照线上的日志去统计最高请求频率可能会有多少，然后我们再乘上一个系数，比如1.5或2。因为如果超过这个频率，它的概率是很低的，如果超过了可能就是一些恶意玩家的请求吧
听起来像是一个熔断的机制
    这个主要还是用来防止一些恶意玩家的，可能单个玩家发送很多很多请求去消耗服务器的资源。像熔断的话我们是有另一套机制的，我们逻辑线程会跟某一个消息队列绑定，我们会限制这个消息队列的长度
这个令牌桶就是一个玩家一个是吧。然后玩家发送的频率，就是以一定的频率往这个令牌桶塞协议对吧
    塞的是令牌
它是怎么控制这个频率
    频率是一个常数啊，就是按我们配置的去控制
比如往桶里塞一个令牌，怎么来计算这个频率，没有很理解
    就是根据我们线上日志的情况，会统计出最高频率是多少，比如每秒多少个请求这样
然后你这个令牌桶就是统计每秒有多少个请求
    倒不是统计请求频率的
    你可以理解成像体力恢复算法那样。因为是隔一段时间去恢复一下体力，然后如果有体力你才能去打关卡
我还是没有懂这个令牌桶算法是怎么限制协议频率
    可以把令牌比作是体力啊，因为只有你有体力才能去打关卡。就是会限制一个总体的频率吧，然后令牌桶会允许一定程度的突发。就是比如很长一段时间没有请求，这个时候令牌会积累上来，然后你可以一下子发很多个请求。但一下子发很多个请求会把这个令牌给消耗完，之后就不能继续发送很多请求了，要过一段时间等它令牌恢复
就是我发请求的时候先从令牌桶里面拿一个令牌，拿到之后才能发是吗
也就是令牌桶里的令牌剩余的越少，就是快到了频率的上限是吧
一个人想往服务器发很多协议，每发一条协议就要从这个桶里放入一个令牌
    是拿出一个令牌
哦，就令牌有一个总数，总数就是它的频率上限对吧，令牌桶取光了就意味着下个协议不能再发了

你那个Jenkins分支构建任务，我没有看懂具体的问题是什么，你是怎么解决的，15分钟优化到3分钟
    因为我们Jenkins它本来，我们是有很多个分支同时开发的。当你新开一个新的分支，要在Jenkins里面配置一个对应分支的任务。然后每个分支会有多个任务，就是这个开任务的过程它很麻烦
一个分支为什么会对应多个任务，这个是开分支的任务是吧
    就比如我们分支会有proto编译成cpp源代码的任务，还有服务器构建的任务，然后服务器可能会有不同的模块吧，不同的模块可能对应于不同的任务。比如我们C++的就用make那种命令，但C#代码它可能是客户端那边去管理的，它可能是存在P4上面的，我们服务器是存在git上面的，所以这两个要分成两个任务去构建
就是仓库比较多是吧
    对，每个分支又会有很多任务嘛
这个是打分支的任务吗，还是开分支的任务
    应该说分支构建的吧，它是构建出我们的服务器程序这样
是每个分支打包是吧。然后你继续
    因为Jenkins开这个还是挺麻烦的，因为每个任务可能配置都不太一样啊，而且要改的地方会很多，所以开分支的时候改起来就很麻烦了，且容易出错。我是把一些配置给抽出来，抽到一个数据库里面，然后用一个任务就可以打包多个分支的服务器。我任务会去读数据库去打包，然后数据库里是只存储了分支名之类的东西，就简化了很多，因为本来可能要存储一些像是git路径、perforce路径这些东西。我最后是改成了一个分支名，在脚本里面就可以拼接出它的路径
就是每个仓库的分支名其实都相同对吧
    是这样，就是有一个规范吧。但是我们会有多个分支，每个分支的路径会不一样这样

你对网络同步有了解吗，比如帧同步和状态同步，讲一下它们的理解
    状态同步就是服务器计算完之后，给每一个客户端同步计算的结果，比如速度、位置是到哪里这样
    帧同步其实就是同步状态变化的原因吧，比如客户端按下某一个按键这样，同步这个原因，让客户端自己去计算下一个状态是怎么样的
那帧同步的最大问题，除了刚才说的一致性问题，它的防作弊的话应该怎么做
    帧同步它会把操作都发给所有的客户端，那可能会产生一些透视的问题。比如FPS游戏、MOBA游戏，可能远的一些单位不应该给这个玩家看到的，但因为他的操作发送过来了，所以客户端还是会有这个单位的位置信息之类的
    反作弊的话，像腾讯那边MOBA游戏的话，它会让每一个客户端进行一个投票吧。如果某一个玩家的计算结果和大部分玩家的计算结果是不相同的，那可能判定这个玩家可能是作弊了
服务器来仲裁是吧

你对MMO寻路的算法有了解吗
    有了解吧，像游戏里面寻路的话一般是用AStar这种算法。AStar其实就是类似于Dijkstra和最佳优先算法的一个权衡吧，它会引入一个启发函数，然后每次选择下一个结点的时候会按照这个启发函数决定一个优先级，每次选择优先级最高那个
    这个启发函数它可能会考虑这个结点到起点的距离，再加上这个结点到终点的距离。像Dijkstra它就只考虑这个结点到起点的距离。AStar它这么做主要是为了减少搜索空间吧，就是能更快速地找到这个结果，但找到的结果它不一定是最短路径，它可能是比较合理的路径。像Dijkstra它会找到一个最短路径，但是搜索起来会比较慢
对于这个A星算法，你刚才说减少搜索空间嘛，但它的open表依然很大。open表你知道是用来做什么的吗
    就待搜索的结点嘛
就A星有open表和close表，它们两个你知道是做什么的吗
    有点不记得了，应该有一个是下一次应该搜索的结点集合，和一个已经搜索过的结点集合吧
    （open表示正在处理或者准备处理的点，close表示已经处理过或者不处理的点。其实没记错的，只是表述有点不准）
那这个open表你觉得用什么数据结构比较合适，能够提高它的效率
    优先队列吧
为什么呢，用哪种优先队列
    像是最小堆
最小堆为什么效率会比较高
    因为下一次搜索是要选择优先级最高的结点去搜索嘛。然后最小堆取最小那个结点是O(1)的，删除和添加的话是O(logN)，相对起来也是比较快的

然后游戏中的一些怪物啊，它们的AI一般是怎么实现的
    （AI看过一点，但是不熟，参考 https://www.cnblogs.com/KillerAery/p/10007887.html）
    听说过应该就是行为树吧
行为树大概是什么原理
    里面会有不同节点，像是条件判断的结点，最后执行的结点，还有一些并发执行的结点。去执行的话就是从根结点一直去执行，最后找到一个叶子节点就是应该执行的操作，然后AI再去执行这个操作
那行为树跟状态机有什么区别，为什么游戏开发一般都选择行为树而不选状态机，状态机其实也可以实现AI
    我觉得可能就是比较直观吧，比较符合人类思考的步骤，因为怎么决策的都可以在树上看出来
状态机也可以，状态机有状态转换
    或者说添加一个新的行为会比较方便吧
那状态机添加一个新的状态也不会很麻烦，它们缺在哪里
    但如果要添加一个新的行为，可能会需要考虑所有的状态
那行为树加个结点，对比状态机有什么优势呢
    因为这个它看起来比较符合人类思考的步骤，所以加一个结点可能找起来比较快

游戏中常见的视野计算的算法讲一下
    就AOI嘛，有九宫格、灯塔、十字链表这种算法
能不能一个一个讲一下
    像九宫格和灯塔是划格子的算法，把整个地图划分为一个一个等长的格子，然后计算视野是时候就是根据实体的坐标计算出落在哪一个格子里面。九宫格的话它的视野范围就是你周围的9个格子啊，或者周围一些格子。灯塔的话它是格子划得大一点，最后灯塔计算出来可能是周围4个格子。以格子里面的实体作为它能看到的实体
    十字链表的话它是分成X和Y两个链表，我们会按照实体的坐标去排成两个链表，然后每个结点可能会有2个哨兵结点吧。实体移动的时候会调整链表中结点的位置，当结点跨过一个哨兵节点的时候，我们就判定这个实体可能进入了视野范围或者退出了视野范围
九宫格移动的时候怎么计算，有些会离开你的视野，有些会加入你的视野
    九宫格会算出实体落在哪个格子里面，当你移动的时候如果没有跨过格子的边界，视野是不变的。如果跨过了格子的边界，再计算出原来的格子是什么，新的格子是什么，然后取他们的差集吧。就是原来没有的，新的视野有的格子，就是进入视野范围的格子。原来有的，新的视野范围没有的，就是退出视野范围的格子
    然后AOI的话我们会维护两个列表，一个是观察者列表，一个是被观察者列表。最后就是遍历这些格子去添加或删除这两个列表

能不能讲一下你们存盘是什么机制
    我们平时操作数据都是在gameserver的缓存里面，gameserver会定期保存到数据库，或者是操作了什么重要数据，比如抽卡或充值，会立刻发送一个保存的请求。保存是先序列化玩家数据到一个包里，然后把这个包发送到dbserver，然后让dbserver去保存
你们用的是MySQL吗
你们数据大概是怎么存的，因为游戏数据一般是文档型，KV结构的，但是MySQL是关系型的
    就我们一些基础的数据会单独一个字段，比如UID、昵称、等级之类的会单独一个字段。像其他的系统的话，就是序列化之后存到一个二进制的字段里面
那你们定时存盘是多少时间
    应该是2分钟
2分钟是把全量数据打包存到数据库，还是增量
    就是全量的
那你们这种结构有可能做到增量的，只存变化的吗
    按现在这个是不行的
如果让你改造的话有什么办法
    比如可以存储层和逻辑层分开来吧，存储单独在一个进程里面，这个进程是一个已经反序列化的结果，它可以访问到玩家的每一字段。像逻辑层要操作的时候就先去拉一下需要的字段，操作之后再告诉存储层要修改哪些字段，修改的值是什么。再让存储层写进去
没有懂你这样如何做到了增量存，你的存储层还是全量写嘛
    你说最后写到数据库要增量吗
    那可能要换一个数据库吧，换成MongoDB。MongoDB里面存的就是一个文档嘛，最后可以去指定把某一个字段改写成什么
MongoDB的话哪个指令可以直接改写某个字段，具体是哪个指令
    这个我不太了解，MongoDB是很久以前用的
你们存盘是2分钟，有两种情况，如果数据库宕机的话你们怎么处理，第二是游戏服务也宕机了那么应该怎么处理，因为2分钟会丢很多数据
    像数据库宕机的话，我们dbserver会有一个存盘的队列，它会循环去存盘，如果存失败了就重新塞回到队列里面再去存。gameserver的话，因为gameserver本身有一个缓存嘛，它存盘是需要dbserver返回一个成功的消息的，当存盘成功才会把玩家缓存给清除掉。如果一直存盘不成功的话，就会一直重发这个存盘的请求
    gameserver宕机的话，其实大部分情况是没问题的。因为我们有一个定期存盘，然后改了一些重要的数据会立刻存盘，如果要丢的话就是丢一些不那么重要的修改了。如果玩家比较在意这些修改的话，玩家找上来了，我们这边会拉日志给他验证一下。验证完之后会通过运营的手段，比如给他发一些邮件去补偿一下

你们用的是什么语言
怎么做线上热更新呢
    更新的话我们是有两种方法。一种是灰度发布，就是分批去更新，先把流量给切到其他服务器，然后再把这些服务器给更新掉，再把流量给切回来。另一种就是热更新嘛，我们会把新的代码给编译成一个so动态库，然后主程序会去加载这些动态库，然后获取哪些函数是需要替换的。对于需要替换的函数，给函数开头写上一个JMP指令，jump到新的函数开头那里，可以实现热更新的功能
可以改写函数对吧。还有一种是我要修内存，内存里数据是错的，我想在线把它改掉，应该怎么改
    我们会事先做好一些手段，比如运营配置一个消息，然后把玩家的数据给改了。因为要改的数据其实是有限的嘛，可能就发一些物品或者扣一些物品，或者是一些活动数据之类的。我们会事先做好一些改这些数据的指令吧，然后运营可以动态地给他发这些指令
我指的是这些之外，比如这个程序某个临时变量需要修改，某个哈希表的值需要修改。你们又实现没做指令，这种情况应该怎么去修
    这种情况我们还是用灰度发布的方式吧。就是还是把整个服务器更新了
那刚才说的so的原理是什么，它为什么可以替换掉进程里的函数
    就冯诺依曼架构的话，它数据和代码都是存在内存里面的嘛，只是操作系统可能给这段内存上了一个保护，比如代码段平时就是不能写入的。我们可以用操作系统的系统调用去修改这个内存页的保护，然后是可以改它的代码，在函数开头写上一个JMP指令
让它这个函数跳到你们的so里面
你是把它的地址换掉是吧
    也不算是地址换掉，就是在原来旧函数的开头写上一个指令，跳到新函数的开头。相当于本来应该调用旧函数的，现在都调用新函数去了
就跳到另外一个函数
那能支持新增函数吗，比如新增一些函数，让其他地方多调用一次这个函数
    它还是只能替换掉原本的函数，可以在原本的函数再新增一个调用新函数的指令，然后把原本的函数给替换掉

你们断线重连大概是怎么做的
    gameserver玩家数据会有一个延迟下线的功能吧，就是比如10秒没有心跳才会给这个玩家下线。但是如果10秒内玩家再连回来的话，因为玩家会连到gateserver嘛，然后gateserver会查询这个UID登录到哪台gameserver上，再把登录的消息发送给对应的gameserver。gameserver这时候它是有一个延迟登出的嘛，这时候可能原来的玩家还没有下线掉，然后又来一个登录请求，就会把新的登录绑定到原来的玩家上，就不继续给它下线了
等于是走了一次重新登录是吧
那我怎么和客户端的状态保持一致，其实我没有重新登录，我只是做了一次重连
    其实也是和新登录一次差不多，客户端这边会拉取一些服务器的数据。只是拉取的没有重新登录时这么多吧，因为大部分的数据第一次登录时就已经拉取过了
等于是有两条协议，第一条是正常登录协议，第二条是断线重连协议
    也不是两条。就是客户端刚启动的时候会生成一个随机数，然后登录的时候我们服务器这边会记这个随机数。那么断线重连之后，因为客户端程序没有重启，这个随机数是不变的，可以根据这个判断它是一个重连。如果这个随机数变了，我们会判断它是一个新登录的客户端
断线重连的时候服务器不需要发跟登录一样多的数据，然后服务器怎么判断应该发哪些数据给客户端
    这个我们主要还是由客户端来拉的，一般不会主动推给客户端吧
它要什么数据就给什么数据是吗
那对客户端来说岂不是很复杂，它漏哪条请求就没数据了，出BUG了
    但客户端必须要知道啊，因为有什么数据需要的只有客户端才知道
有没有可能设计一种更好的断线重连，让客户端和服务器都减少工作量。尤其是客户端，一般对客户端的请求量还是蛮大的
    没想到，要不还是全量重发一遍吧，全量倒也没这么大
全量就是流量会比较大是吗

有一个比较开放的问题，COC你有玩过吗，就是皇室战争。我给你简单聊一下它的玩法，就是有一个地图，上面有些建筑和一些怪物，我把我的兵放置到场景里，这些兵就可以自由地攻击这些建筑和怪物。就类似于星际争霸，你玩过星际争霸没有。我放置一大群单位，这些单位自动地攻击这些建筑，大概就这样。如果让你来实现COC这样的玩法，你觉得有哪些技术难点是要解决的，解决方案是什么
    首先要定时去更新这个状态吧，定时的话需要一个定时器，比如每隔多久去执行一帧的逻辑。在帧逻辑里面，还是像刚才提到的一些，会有些寻路、AI、视野之类的东西。视野的话可以给每个单位去维护一个视野，就是它附近会有哪些实体。然后被观察者列表会用来做一些AI的计算，AI从被观察者列表里面，可能选择一些敌对的单位去攻击
这里面提到几个，首先是寻路，你放置的单位数量很大，比如说有500个，1000个，那寻路算法应该怎么选。这个需求每个单位都是一个独立的个体，需要独立去做，也需要有独立的AI
    主要还是AStar吧
但是A星算法的话对大规模寻路效率很低，比如1000个单位，尤其是当地图比较大的时候，有什么优化手段吗
    （可以参考 https://www.zhihu.com/question/20298134，比如选一个leader，周围人跟着它走。但是这里限定了每个单位独立去做，所以可能不能用这种方法）
    可以给些结果缓存一下吧，比如缓存这个格子到那个单位的路径吧，然后寻路的时候如果搜索到已经有结果的格子，那就直接用它的结果
因为建筑可能会阻挡，那建筑被打掉的话，这个缓存需要重写
然后还有AI吧，AI应该怎么做，它怎么去释放技能
    也是根据单位目前的状态吧，比如当前已经决定了一个攻击的目标，那就继续攻击吧，先不变。如果当前是空闲的，再去看一下附近有没有可以攻击的单位。可能根据策划某种算法算出攻击单位的优先级吧，然后再去攻击
然后还有一个问题，像这种COC游戏，客户端和服务器同步的话用哪种。因为它的单位数量很多，怎么去同步，包括校验的话
    主要还是帧同步吧，因为会有很多单位。但我觉得其实可以把两者结合起来，可能每隔多少帧去记录一个全体的状态。因为可能会有玩家重连，或者新假如一个对局的情况吧。新加入的可以把最近一个状态发给它，然后把后面的操作再发给它，这样同步起来会比较快
对这种游戏用帧同步的话，你觉得哪些玩家作弊的行为要提前去处理
    比如像透视啊……主要还是透视吧
战斗结果呢，因为帧同步意味着客户端跑AI或寻路，那它可以随意作弊。改一下目标的建筑，那些怪物直接让它们死掉，每次攻击都死，直接影响游戏结果
    但如果说每一次攻击都死的话，这个听起来更像状态同步吧。因为帧同步的话我感觉就是，可能同步给它当前要攻击的建筑是哪一个，攻击扣的血量都是自己去计算的啊
因为帧同步服务器其实……就是重新来选的话你选择哪个方式
    就还是刚才的，两者结合吧
那状态的话，服务器会记录哪些状态
    比如实体位置，还有血量之类的吧。而且服务器本身可以做一些校验的，比如某一个实体不能移动得太快，然后攻击的血量也不可能一次扣太多吧，扣了多少服务器是可以计算出来的

你平时喜欢看哪些技术书籍，可以分享一下
    主要最近看的都是一些像框架之类的吧。也不一定是书籍，我自己会看一些博客、文章之类的。像看了skynet的一些解析吧
可以分享一下你最近看的一些内容，简单分享一下
    比如skynet，我了解过它的消息分发的机制啊。它会有一个全局的队列，全局队列里面是一个次级的队列。次级消息队列它是对应于某个Actor的消息队列的，里面就是一条条的消息。它会有多个worker线程，worker线程每次先去全局队列获取一个次级消息队列，然后去消费次级消息队列里的一条或多条消息。消费完之后如果还有剩余的消息，再把这个队列放回到全局消息队列里面。因为同一时刻只有一条线程能获取到次级消息队列，所以操作这个Actor的时候它是线程安全的
平时你都看哪些方面的技术，或者技术的信息、文章什么的
    还挺多的吧，我可能去GitHub看一下最近火的榜单，像最近的话会有ChatGPT啊，Stable Diffusion之类的。然后还会去了解一下微服务吧，微服务它会有Consul啊，作为一个服务注册、服务发现的中心吧。像新版的话会有一个Sidecar，用来做一些微服务之间的通信吧。最近的话会有那个Service Mesh，就服务网格，用来替代以前这些服务注册、服务发现的
然后你平时看的这些东西有哪些新方法引入到工作中的，有案例可以分享吗
    这个倒不会，因为引入一个新技术的话会考虑它的成本、风险、带来的收益什么的。因为引入的话首先需要一个学习成本吧，像团队里面的人也是需要去学习的。风险的话，比如你会修改以前的一些功能，修改之后怎么保证它还是能正确工作呢。像收益的话如果你引入之后和引入之前，能做的事其实差不多的，那我可能不会再去考虑引入这个东西了。就有一个利弊的权衡吧
那你有尝试引入过，先不说利弊权衡，有这样的想法或者案例
    想我自己做的服务器工具箱，它本来是用Flask的嘛，后面是有一个新的框架火了，它叫FastAPI。因为它里面会有一些比较好的特性，比如可以用Python的类型标注，去自动实现参数校验的功能。我会去看它是怎么实现的，我会去引入它底层的库，然后利用一些装饰器这样的手段去实现和它类似的功能
你对于个人未来，有哪些短期和长期学习的规划
    我目前是对Go比较感兴趣，所以目前首先看了官方文档的Go之旅那些文章。然后接下来准备看Go的一些标准库它有哪些功能，再去看一些博客，比如Go的一些惯用法，它常用的框架有哪些，它们是怎么实现的之类的
你在这三年的工作过程中，你觉得哪方面做得不够好，需要提升。包括工作是不是有更好的方案选择
    可能我向上管理做得会比较差一点，因为大部分时候就是自己在苦干啊，干出个结果再向上级同步。像这种我可能以后会多沟通一些吧，像是把我每天做了什么，做到哪种程度了，然后可能会有什么风险，都同步给上级
你觉得这个沟通的好处是什么
    因为像管理层的话它可能要把握团队里面每个成员，他的进度、他的风险是怎样的。然后万一就有什么风险了，那上级可能会做一些资源的调控，比如找一些人去帮你分担一些，就是尽量保证这个事情是在推进的，就不要卡在某个地方
然后你平时跟策划还有客户端的程序、QA的合作模式大概是怎么样的
    就比如要新做一个需求的话，我们会去开一个需求评审会，主要是评估一下这个功能能不能实现吧，具体怎么实现，需要哪些接口之类的。我跟客户端会去约定一下需要哪些接口，然后接口的proto的定义是怎么样的，然后就是去实现接口吧。像QA那边的话，比如做完了再去告知QA一下，你可以去测试了。然后测试有哪些需要注意的地方，因为代码还是你写的嘛，具体有哪些路径你会知道的，那会具体跟QA说一下有哪些需要注意的情况
然后你自己自测全部能（录音没听清）
    自测我们服务器会有一个用来协议测试的机器人，我们会给机器人去写一些脚本，让它发包到服务器，去比较一下返回来的结果是不是符合预期的。我们会对每一个异常情况，包括正常情况啊，做一些测试，尽量覆盖每个分支吧。也会去看玩家的状态是不是正确的，因为执行完这个协议之后玩家数据会变成什么样的
你自己觉得自测质量怎么样，交付出去之后，QA反馈的BUG多不多
    还行吧，就大部分的问题我自己自测的时候就发现了
你个人对于自测的看法呢，你觉得自测对你的开发过程中，这个重要程度有多大
    还是很重要的，因为谁都不能保证写完代码就是没错的吧
你觉得自测跟你写代码的关系是什么样
    像是一个验证的过程吧，还是很必要的过程吧

反问
    你们服务器可能会遇到什么难点吗
        难点挺多的，主要还是性能问题，线上经常出现一些卡顿
    你们会期望团队里面人是怎么样的，有什么技能，或者是性格是什么样之类的吧
        技能的话其实就是基本的，服务端基本技能就OK了。然后我们还期望大家比较好学一点，始终保持一个成长性的思维，不断地进步。对人的要求基本上是这样


------
整个面试85min，快吐了
其实有些问题和一面是重复的，比如寻路、AOI。这次还问到了AI，但确实不太熟
网络同步还需要再加强一下
