自我介绍

你觉得做得比较好的，让你比较满意的，能展现你能力的，是哪个方面
能简单讲一讲吗
    我们排行榜是分为两种，一种是全量的，就是所有上报上来的玩家都会保存，另一种是只保存前几百个这种
    全量的我们是用Redis去实现的，用了Redis的Zset的数据类型
    前几百的话我们是直接用map做在我们自己进程里面的
假设一个很大DAU的游戏，玩家数量很多，做一个前几百的你会怎么做呢。如果只需要前几百的，比如说是个战力排行榜吧
    我这边是用一个map，然后里面是以战斗力 + UID作为一个key，value就是玩家的信息
那有新的玩家数据来的时候怎么知道自己是不是应该在这个榜里
    首先看一下这个榜的人数是不是到上限了，如果没有到的话是可以直接加上去的
    然后如果到上限了，先看这个玩家原本是不是在这个榜上，如果原本在这个榜上那就把原来的删除掉，然后再把它重新添加进去
    如果原本不在这个榜上，那就把最低分的删除掉，再把这个玩家给添加进去
那怎么判断自己原来在不在里面
    可以用一个哈希表，就是unordered_set（被打断）
你刚才说你的key是UID和分数，是两个key吗
    它两个是作为一个tuple去存到一个key里面
那怎么判断一个玩家在不在呢，只有一个UID的情况下
    就是在原来这个map的基础上，再加一个unordered_set吧。set里面可以存储所有在榜上的UID，然后直接去set里面找就可以了
那假设他在里面，然后怎么去更新map呢
    这种情况用set可能不够了。可以把原来的unordered_set换成一个unordered_map吧，这个map里面以UID为key，以原来那个map的迭代器作为value
    所以可以直接用UID去找到这个迭代器，用迭代器去删除原来的结点
这样的情况下，这个排行榜会频繁地请求吗。比如玩家每个客户端可以拉到这个榜单吗
    会有
如果要拉榜单怎么做呢，比如要拉前100名吧
    就用迭代嘛，迭代100次，最后得到一个vector嘛，把它发给客户端
这样每个玩家想来拉排行榜都得去迭代100次对吧
    如果是性能要求很高的情况下，我觉得可以在玩家的服务器上面做一个缓存吧
玩家的服务器是指
    就是玩家服和排行榜服务器是分开的嘛
是不同的进程吗还是不同的机器
    是不同的进程
所以是在这个进程内做一个缓存是吧
    是，读的时候就读这个缓存

那还有一个问题，还是以这个排行榜为例，比如维护了前100名玩家，有新的玩家过来时会去检查在不在里面，这样的话有没有可能还有一种情况遗漏了呢
你么这个战力是只会增加不会减少的吗
    哦，我们没有那种会减少的分数。我们都是只会增加的分数作为榜单的
那假设啊，现在需要做一个王者荣耀天梯积分之类的排行榜，可能涨分也可能掉分，如果会掉分那这个排行榜应该怎么做
    其实如果只要展示前100的话，那可以不只存储只有前100的，比如我可以存储前500的，就算掉出去了，也会有100名以下的再升上来
也就是维护前500对吧，那第500名的人如果掉出去了呢
    就是客户端展示的时候只需要前100的嘛，我不需要把完整的榜单展示给他，完整的其实可以多保存一点。那如果前100名掉出来了，多出来这些还会再顶上去
具体比如我们写代码时你会去怎么实现多出来的部分
    就还是和原来一样吧
比如我们定一个值，虽然客户端只需要100，我们定个500
    可以是客户端需要的，再乘上一个倍数吧
假设就500个吧，那怎么维护500个这样的表，还是用刚才的map和set吗
    还是和之前一样的方法
那么假设当前的第500名这个玩家，它的分数变少了，会发生什么
    可能有其他实际上在500的，就是可能有其他玩家分数比他高，但是没有上到这个榜上
这样会有影响吗
    其实不影响，因为我们这么设计，它主要还是因为客户端只展示前100的。所以多出来的这一部分，其实不这么严谨也可以

做这样一个排行榜，你刚刚说是放在内存中，那服务器会有重启，或者维护，那应该怎么处理
    那像修改排行榜的时候，我可以给它添加一个标记，标记这个排行榜是脏的，然后我会把它存到一个待保存的队列里面吧，有另一个线程去定期给它存储一下
是存到数据库里吧
你刚刚提到这个排行榜进程和玩家的进程不是同一个进程，所以你们维护的时候是一起维护的吗
    不是啊，就排行榜会有自己的数据库，玩家会有自己的数据库
有没有可能排行榜进程需要维护一下，但玩家那个时候没有停服呢
    是有这种可能
或者最坏的情况，排行榜这个服务器挂掉了，那如果是这种情况会怎么处理
    就会降级吧，这段时间可能不允许查看排行榜
降级是什么意思
    就可以暂时不提供排行榜的服务
然后怎么来恢复呢
    我们这边是有一个监控进程会重新拉起这个服务器进程的，万一挂了的话
拉起来之后呢
    拉起来之后就是和之前一样正常处理服务了
也就是说拉起来之后要等到比较长的时间，也就是前100名都有一次分数变化他们才会重新上榜是吗
    像排行榜这种可能是比较重要的消息，我们会给它做一个缓存，就是需要有个确认的功能
    就是玩家上报分数到排行榜之后，需要排行榜服回一个确认的消息。那么如果没有收到这个确认的消息，我们可以定期再给它重发一遍这个分数
假设我们设计了这样一个确认的机制，你觉得这个确认的机制应该怎么来写。比如说是玩家身上还是怎么样，怎么设计这个确认机制
    可能是进程里面的一个模块吧，我要发包的时候我先把包交给这个模块，让它缓存一份，这个模块再发送包到其他的服务器去
    同时我会给这个包分配一个ID，其他服务器确认的时候带着这个ID去确认，这个模块收到这个ID的确认后就可以把缓存的包给清除掉。如果没有收到的话，我们可以用一个定时器去重发这个包
搞一个定时器去重发这个包是吧，比如定时10秒这样
那如果这样来实现，也就是每一个包都需要开一个新的定时器
    也不一定用定时器，比如可以这个线程本身是一个循环，可以sleep几秒钟，重发这样
sleep几秒钟，但是你不是说是进程里的一个模块吗
    这个模块单独用一个线程吧
单独用一个线程，然后发一个包就sleep这样吗
    或者也可以，它单独在这里循环处理消息嘛，当它没有消息可以处理的时候，判断一下距离上次发包过了多长时间，过了这个时间就可以再发一个包
当它没有消息的时候我们判断过了多长时间
    就这个线程它会循环处理一些消息（被打断）
你方便共享一下桌面吗，简单写一下刚才说的逻辑
    （有点小问题，发包的priority_queue可以改成queue，因为是按时间顺序加入队列里的。发包之后没有重新加回队列里，被指出。判断时间用了if可以改成while，但不是大问题，因为下次循环还可以再发）
CachedPacket这个map是什么时候被清理的呢
    处理消息的时候吧，因为确认的时候会回给我一个消息，然后把消息再转到这个模块里面，这个模块处理消息的时候就可以去清理
所以确认是怎么确认的呢，是由另外的模块去调用它的方法吗
    就是另外的模块吧，我们的网路线程是接收网络的消息，然后把消息push到一个队列里面。我们的worker线程会去处理消息，如果发现是这个确认包的消息，就再转交给这个模块吧
具体怎么转交给它
    也是通过这个消息队列的，会有一个pushMsg的接口
    （写了一下pushMsg方法，为了线程安全加了一个mutex）
如果有这样一个模块，你觉得在用的时候有什么需要注意的吗，假设这个作为服务器的一个基础模块
    像是初始化还有停止的时机吗
不是初始化和停止，我只是说发消息，比如你刚才提到给排行榜发消息要确认，这是一个要确认的发包机制对吧。那用这个机制的话有什么要注意的，是所有消息都可以用这个模块来发吗
    （其实面试官想问防重、幂等之类的）
    主要是一些需要确认的吧，我觉得一些重要的消息，比如结算，还有排行榜算是比较重要的
都可以用这个来发对吧
    嗯。它的消息路由可能需要注意一下。就发到哪个服务器吧，需要把它的路由参数再传给这个模块
那除了这个接收者之外呢，比如你刚才提到结算，如果结算使用了这样一个机制的话，会不会产生额外的BUG
    你说可能多次结算之类的吗，一般会通过一个业务的ID去重。比如结算消息可能会有一个ID，那么接收方那边会去记一下已经处理的消息的ID，如果已经处理过这个消息，那就不再处理了
所以结算去重是得写在这个结算业务逻辑里面对吧
    是这样的
那有没有可能我们在这个消息的层面就保证，发送且只到达一次呢
    可以做在这个CachedPacket里面，它里面可能会有一个ID，然后我再去记一下已经发送的ID
    但是我个人觉得的话，其实还是接收方去做去重比较好。因为只有接收方才可以保证，这个标志还有包（处理）它是同时去添加的，接收方可以保证这个原子性
对啊，但是你提到的接收方需要保证原子性，那排行榜可能需要做一次，结算也需要做一次对吧，不同的模块都需要做一次保证原子性，有没有可能统一来做
    比如可能玩家数据上记一个我已经处理的需要重发的包ID，处理消息的时候再去判断一下这个消息是不是处理过了
就记在这个玩家的身上对吧。其实你已经写了这样一个模块，那你这个模块也可以负责收消息对吧。既然能负责重发，它也能负责收这种需要确认的消息。是不是在这个模块内可以把所有的收和发和去重都做完了
    但我个人觉得去重还是做在业务需要的地方，因为它可以保证原子性。做在不同的线程的话，可能我这个数据写了，但那个数据又写失败了，可能会有这种事情发生
是会有这个最终操作的原子性，但是比如我们确保这个消息只会重发一次的话，是不是可以保证
    从消息这层面来说的话倒是可以

除了排行榜，其他的业务你觉得还有做得比较好的部分吗
    （还在思考，还好转移话题了）
或者我问一下，你们所有业务都是拿C++直接开发的吗
    是的
那比如说在代码规范，代码审查方面有没有特别的逻辑呢
    我们项目会自己定义一套代码规范，比如说代码的风格应该是什么样的，命名上哪里应该大写之类的，另外的话也有一些业务开发的注意事项吧
    比如我们会规定涉及到玩家结算的，必须先扣再发，扣就是比如扣除一些货币啊，或者打上标记之类的，然后再给他发奖励什么的。这个是为了保证万一写出什么BUG，中途突然返回了，玩家可能用这个来刷奖励，如果先扣再发的话玩家就不能利用这个来刷奖励了
是的，这个是比较好的习惯。我们写了这个代码不可能完全没有BUG，假设一个代码放到线上，我们要怎么去处理这个问题。比如这时有很多玩家报上来，我们要怎么去排查呢，你有遇到过吗
    有的，像这种的话，我们是事先做好了很多运营的手段啊。比如一些重要的玩法，我们会有一个开关。如果这些重要的玩法出了什么BUG，可以紧急关掉这个玩法，不让他进去
    然后我们日志方面会做得比较详细，我们日志会记录像获取到的奖励，获取奖励的原因，还有消费一些东西的原因之类的我们都会记下来。万一出现了什么，我们可能漏发一些奖励吧。我们会让数据平台去拉一下日志，看他比如达成了某个条件，但又没有领到奖励的那些人，把他们拉出来。然后我们运营那边可以给他补发一些邮件什么的
比如说发现了某个玩法，有个代码的问题，那怎么去修复这个问题。你刚才只说把开关关了，那玩家就玩不了了
    修复的话，首先是根据日志，或者线上可能出现coredump，那么这时候我们会去看它的调用栈。根据这些去排查哪些代码可能出了BUG，然后去修复它。修复之后就是把新构建的二进制文件上传到服务器，替换掉原来的，然后重启一下服务器就行了
所以最终是要把服务器重启一下是吧
    有的是重启啊，如果是一些很小的逻辑，我们是用了一个hook的方法
    就是比如原来这个函数是那样的，然后我会把新编译的二进制文件，把它编译到一个so库里面。然后我的服务器进程可以去加载这个so库，然后去看它有哪一些函数符号是可以改写的。然后我们会在原来函数的开头写上一个JMP指令，jump到新的函数里面去，可以实现一个热更新的功能
这个很好啊，这个部分你是看过吗，还是有现成的方案呢
    我本来是看过一些吧，我们服务器也是这么实现的
这个部分你有参与吗，还是是已经写好的模块
    没有，之前是了解一些，然后这边这的话是其他人去做的
那比如说我加载一个新的so文件，然后怎么知道具体哪些函数需要被hook呢
    加载这个so文件，它可能会有一些导出的函数符号，像Linux的话可以用dlsym这个函数去获取导出符号的地址。比如这个so库导出一个获取需要替换的函数列表的函数，那么进程可以获取到这个函数地址，然后去调用它，就可以得到一个需要替换的函数列表
那比如新加载的这个so是完整的服务器代码吗
    就是需要替换掉哪些函数就有哪些函数的代码
那我们怎么快速得到这样的so呢
    我们是基于原来的makefile去改的。原来makefile可能是编译整个服务器的嘛，如果我要新创建一个so，其实只需要吧对应的源文件编译就可以了
这样的一个方法，在旧函数开头插入JMP指令，那这个指令是直接跳到新的函数的位置吗
那如果这个新的函数的参数发生变化了呢
    我们不会这样，因为hook这个功能主要是做一些小的修改的，它不会涉及到函数参数的变化。如果真的是很大的修改，我们还是直接编译整个服务器，然后重启了
如果重启的话当前在线的玩家是怎么处理
    在线玩家我们是先给他踢掉然后才能重启的
就是把在线的玩家踢下线，然后重启，再等他们自然登录是吧
    踢下线的时候玩家数据会有缓存吧，先给我们的数据库服务器去发一个保存的请求，等这个保存请求成功确认之后，才可以把这个玩家缓存给清除掉。等所有的玩家缓存都清除掉了，才能重启这个服务器
那有没有调研过或者了解过行业内其他一些公司的做法，对于线上修问题的话
    我了解腾讯他们会用一种共享内存的方案，存储和逻辑分开，存储玩家的进程它可以不用重启吧，因为它只负责一个存储的功能
那这个方案你觉得会更好吗
    共享内存它可能会有其他的坑啊，比如读写玩家数据的话可能需要进程之间同步的机制，而且共享内存也不支持一些复杂的数据结构，比如指针什么的
共享内存读取需要同步的机制
    就是进程之间同步嘛，比如用一些信号量，或者互斥锁什么的，就防止多个进程、多个线程同时去读写一块内存
但是你刚才说只是把数据和逻辑拆分开啊，数据这边不会读写，其实还是只有逻辑这个进程会读写
    （尬住了）具体其他一些缺点我也没有了解过

那你自己在这几年有处理过线上的事故或者问题吗，给你印象比较深刻的是什么
    主要都是刚才那些过程吧
能讲一个具体的例子吗，你这么多年没有写出过线上的BUG或者问题吗
    可能有一些活动结算的时候，有部分奖励没有领取到奖励啊。可能这个玩家没有领取奖励，但活动已经过了时间了，我把它给关闭了
是这种活动已经关闭了，但玩家没有拿奖励这种是吧。最终是通过日志补发是吧
那服务器还有一种比较危险的情况，比如一个服务器在线上挂了，这种情况下要怎么去处理
    Linux挂了会生成一个coredump嘛，我们会有一个监控的进程把服务器重新拉起来，尽量不让它停机吧。然后coredump会触发我们运维平台的告警，我们收到告警之后会登录这个服务器看它的调用栈调用到哪里了
登录这个服务器就是指刚才挂掉的服务器吗，具体是怎么看这个调用栈呢
    我们是用gdb去看
你有线上操作过吗，具体是怎么看这个调用栈的
    就gdb这个进程，然后coredump的文件嘛。gdb里面的命令就是bt，bt就是查看当前调用栈调用到哪了
那这个调用栈里面是带符号的吗
    会带这个函数名啊。像当前执行到哪一条指令都有的
那比如说上下文的，内存中的临时变量呢
    就用p变量名这个命令
比如说重新把这个进程拉起来，然后又挂了的话，也是自动把它重新拉起是吧
那这样的过程中会不会有什么风险
    可能重新拉起之后又走到这里然后又挂了，但实际上我们没有碰到，因为这种BUG会比较离谱

你觉得有哪些机制能够保证服务器尽量稳定一些
    我了解过像skynet它的处理情况。skynet的话它是用了一个Actor模式嘛，里面每一个服务它单独起一个Lua的虚拟机，我访问内存就是只访问虚拟机里面的内存，如果挂了也只有这个虚拟机挂，不会影响到整个进程
是的，相当于就是把业务拆开是吧。这个是一个模式啊，就是把不同的业务拆分，如果挂了也只影响自己。那还有哪些机制能让整个游戏服务器更好一些呢，更稳健一些。也可以从程序员怎么让它更好一些，设计上啊，检验上啊都可以提一提
    （想了很久，对这种开放式问题真的不擅长）
    像我们开发还有测试的时候其实是用了一个ASAN这个库吧，它如果发现一些内存问题，比如内存泄露啊，写到不该写的内存啊，或者free之后还在写。这种问题它会检测出来然后写一个错误日志，然后生成一个coredump
就用ASAN去排查一些内存越界的问题对吧
    所以开发的时候就可以把这个问题尽量排查出来避免掉
这是一个挺好的方法，还有吗
    比如我们开发的时候可能用一些防御性编程把，比如每收到一个指针就要去检查它是不是一个空指针
就是通过一些检查，条件判定之类的是吧。还有吗，比如测试方面的
    可能做一些单元测试、接口测试。我们会有一个测试协议用的机器人，就是可以自己写一些脚本，然后让机器人去发协议，看这个协议的返回值是不是和预期的一样
还有吗，你觉得服务器还需要经过什么测试，自己写的这样一个模块
    那不就是单元测试
    然后我们会有一些自动化任务，我们Jenkins上面会部一些任务，去做一些CI、CD啊，自动测试、自动构建之类的
刚才有一点你没提到，我们测试除了正确性测试啊，是不是还有性能方面的测试。比如我新上了一个排行榜模块，怎么知道可以承载多少玩家
    就压测嘛，比如我可以随机生成一些分数，然后插到排行榜里面
嗯，怎么构建一个压测
    首先可以对线上的情况做一个建模吧，根据运营的一些情况，或者是线上统计出来的情况，看哪些协议可能分布比较多的，每个协议分布的权重啊，然后测试的时候就按这个权重去随机发。发完之后我们可以关注一些指标，比如QPS啊，消息处理的时间啊，消息队列是否有积压啊，把压力慢慢涨上去，得到一个最大能承载的QPS，或者最大能承载的人数
你自己有做过这样的工作吗
    压测的话我们是有专人去负责的
比如排行榜进程，光靠一个客户端是压不满的，可能需要非常多的客户端去压测这个服务，很多机器给这一个机器去发消息，怎么协同这些机器同时给业务去发消息呢，我们不可能人肉上到这些机器上，来启动一个程序对吧
    可以写一个脚本，比如通过SSH这样的接口，去给压测机器去发命令，让它开始压测吧
那压测机器有很多呢，比如100台机器，我们是写一个脚本依次上去发是吗
    这是一个推的模式嘛，还有另一种，可以用一个拉的模式。比如事先在每台机器上面部署一个agent，然后agent可以连接一个消息队列的服务，我可以向里面推一个消息，让agent开始压测这样
这个方法感觉会比SSH好一些吧
    其实我们压测机器不会很多啊，一般就是4台8台这样
那可能跟这个具体的业务有关系

然后服务器除了coredump还有可能发生哪些线上的意外呢
    （怎么又是开放式的问题，头疼）
    可能就是物理机器挂掉了之类吧
先不说硬件，程序方面除了直接dump掉之外还有没有可能会有其他问题
    可能消息队列积压之类的吧
比如有没有可能写一个逻辑，在线程里面写出一个死循环
    哦是的，我是做过一个死循环检测的功能嘛
那你能讲讲怎么做死循环检测的吗
    我们是类似于一个看门狗的功能，它是每个worker线程处理完消息之后会上报一下更新一下时间戳，然后另外有一个监控线程，就是检查每个线程的时间戳。如果有一个线程过了很长时间都没有更新这个时间戳，我们会判定它是死循环了
那具体怎么知道死循环在哪里
    因为每个线程是会有个ID嘛，我们时间戳是跟线程ID绑定起来的
是知道哪个线程死循环，那具体能不能知道线程的哪里死循环
    这个可能要根据日志去排查
拿gdb可以做到吗
    可以是可以，但gdb的话可能不太好，因为线上调试的话可能所有的业务都被暂停下来了
    有一个pstack倒是可以做，其实它也是用gdb去实现的，但可能暂停的时间会比较短
    （事后查到可以用gcore生成一个coredump文件，而不停止进程）
只是把当前的状态dump下来对吧
那如果遇到这种死循环，有办法抢救吗
    我们还是用的kill的方法
就是杀掉然后重启一个新的服对吧
除了这种死循环问题啊，还有一种比较常见的，内存泄露啊，不知道你有没有遇到过
    内存泄露啊，因为我们开发时用了ASAN嘛，基本上都可以排除掉
开发时没有这么多玩家的数据吧，都能排除掉吗（啊不然呢）。比如线上发现开服后，内存一直在涨，如果遇到这种情况应该怎么排查
    我们这边是会有监控，它会隔一段时间去采样一下内存的占用情况。比如我发现这个内存，可能过了某个节点会涨一下，那会去找一下这段时间它可能处理了什么消息啊，哪些消息可能造成内存的增长
这样的话还是相当于全部地看消息和代码，有没有可能直接知道哪里分配了内存哪里涨了
    可能对内存分配的函数做一个hook啊，然后做统计啊，哪里可能分配了很多内存，如果我想知道哪些对象分配比较多的话，我直接去找它的统计数据
所以是用了hook这个内存分配的函数对吧
    也可能是new运算符什么的
那一般服务器不会已经hook过吗，你没有hook过吗，你们都是每个模块自己去new的是吧
    （啊一般会hook的吗）
那除了这个问题，还有没有可能在内存方面会有其他问题。比如物理机的内存是有一个上限的，假设玩家上得越来越多，内存超过一定值，然后在Linux上会发生什么
    Linux有个OOM killer的，如果超过一个阈值它可能就把内存占用比较大的进程给杀掉了
在杀掉之前会不会还有别的处理方法
    哦，可能启用那个swap分区，就是用硬盘来代替内存做一些交换吧，可以把一些不常用的内存换出到硬盘上
那这个swap分区是怎么判定哪些内存要被swap掉呢，或者有没有办法知道当前在swap里的是什么
    当前在swap里的没有了解过。但Linux swap的话它是用了LRU缓存这个算法
    （top命令可以选择显示SWAP列，表示每个进程使用swap分区的大小）
按访问的时间对吧
如果用swap分区的话会有什么问题
    因为它是在硬盘上的，它读取会很慢，会把整个系统都拖得很慢
所以swap正常情况下是不用的吗
    我们是不用的

我看你还提到，你还用过一些脚本语言是吧，比如Python、JavaScript，这些是使用了还是有一定的了解啊
    Python、JavaScript我都是在工作中用过的
主要是用在哪些方面
    主要是一些内部工具吧，比如我们Jenkins构建的脚本都是用Python去写的，策划会有导表的脚本也是Python写的
所以主要是内部一些工具的代码是用Python写的
用的是Python2还是Python3
简单问一个Python问题吧，比如往一个dict里面插入数据，有几种不同的方法
    可以直接用操作符去插入（还没说完）
如果我要判定这个key是否存在，如果不存在再插入呢
    用那个setdefault
setdefault它是不存在再插入，如果我想要已经存在就不插入这样呢
    （没懂，setdefault不就是干这个用的吗）可以先用in判断它是否在里面
然后再用插入来做对吧，有没有更简单的写法
    （setdefault不是说了吗）不记得了，我主要还是用setdefault或者in这种方法

你已经离职了是吧
离职原因
空窗期在干嘛
    在准备一些东西，比如复习一些算法啊，复习之前学过的一些知识啊
工作地点都可以吗
工作强度和工作压力方面有什么看法。原来在上一家公司大概是怎样的强度
    上家公司大概每天会上9个小时，然后每周会有一个晚上加班
有一个版本日之类的是吧
那自己有什么看法吗
    游戏行业加班还是挺普遍的吧，只要不是天天加的话我都可以接受
你已经成家了吗
假设你有机会来到网易，你对自己是什么定位，你希望自己在接下来2-3年里，大概从事什么样的工作，你觉得自己在团队里的定位呢
    我主要还是想在技术方面再深造一下，工作方面是想做游戏业务上的开发
自己的长期会有规划吗
    长期的话主要还是想走技术专家的路
关于薪酬和期望方面，方便透露一下现在的薪酬情况吗，base是多少，奖金是多少

反问
    可以介绍一下你们的游戏类型还有核心玩法吗
        我们这边是网易天下事业部Inception工作室，然后工作室是有3款游戏在做。一款是无尽战区，是一个端游的MOBA，而且上线很多年了。然后另一款是叫非人学园，是一款线上的MOBA手游，你可以理解成王者荣耀之类的，手游MOBA都是类似的，然后是一个卡通风格的游戏，也已经上线多年了。这两款游戏都在运营中，今年也会有一些新玩法，以及一些新的世界观设定，包括我们两款游戏会做一些联动、打通，在做这个方面
        另外还有一款游戏其实是在研项目，应该上个月放过一个PV，叫天字七六，不知道你有没有看过这个PV。其实是一个比较概念的PV吧，比较前期的状态，它其实也是继承了非人学园的世界观，我们也是做一个多角色、二次元的卡牌战斗的玩法。你可以理解成会有一点点像崩三，但是它除了战斗之外还会有比较多的探索。另外这个游戏是做了一段时间了，但是中途我们发现有一些方向上的问题，会特别像星穹铁道，所以我们中间做了一次调整，玩法上会有一些变化。目前还处于一个项目前中期的地方（这个项目靠不靠谱啊）
    你们服务器可能会有什么难点吗
        服务器的难点其实有非常不一样的地方吧，比如就算日常的业务也会有很多的难点，在这个玩家的规模和数量上来之后。所以一个是业务量上带来的技术难点，另一方面就是我们追求更稳定地给玩家持续服务的体验。比如像你刚才提到的杀掉一些进程然后重启之类的，我们可能不会去做的。所以会有玩家体验上的一些技术上的点吧，至于你说的具体业务上的难点，可能大家做的排行榜也都差不多


------
整个面试大概70min，结束之后感觉就是口干舌燥
这次有大量的开放式问题，我感觉答得不够好。最好还是沾边的都主动说说，可以展示自己的知识面广，就算说错了面试官也会打断，不会偏离太远
这次是主程面试的，比较注重开发中各种流程怎么保证服务器稳定，还有线上遇到问题的排查，这个纯靠经验了
一天之后收到三面邀请（HR又说期望薪资不要说得太死，看来上家给的还是太高了）
