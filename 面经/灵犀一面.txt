自我介绍

介绍一下你做过最复杂或者印象深刻的系统吧
你们那个排行榜是单服的还是跨服的
    单服的
就是显示一些玩家信息或者什么东西是吧
我看你这个排行榜是基于Redis实现，你们（上家项目）用的是什么数据库
    MySQL还有Redis都有
那你这个排行榜用Redis有落地吗
    Redis有持久化的
就是直接用Redis落地没用MySQL对吧
能讲一下那个排行榜大概花了多长时间吗
    （你怎么不按套路出牌）花了多久我忘了，具体实现要听吗，就排行榜的具体实现
那你讲一讲排行榜它复杂在哪一块
    我们排行榜是单独一个服务器。排行榜需求是有两种，一种是全量的，就是上报的玩家全部都要保存，另一种是只保存前几百个玩家这样的
    全量的我们就是直接用Redis的Zset去实现的，top多少那种我们自己在进程里面用map这个数据结构去实现的
    我们是做了单独一个排行榜的服务器进程
你全量的排行榜大概是什么量级的
    主要是看玩法吧，我看过最大一个榜大概是有6w多这样
那最后在内存里是用什么结构去管理的，有缓存吗。就玩家来查看的时候，那个数据是怎样的流向
    全量的榜的话我们是直接从Redis请求的，前几百这个榜我们是存在自己内存里面的
内存里有用跳表之类的什么结构吗
    我们是用的map，它底层就是红黑树嘛
用map的话你们怎么知道他是第一名呢，你们map里面存了名次是吧
    倒没有名次，因为我们就是前几百名的榜只是用来展示的。就每个关卡可能有这么一个排行榜，然后展示看看谁打了多少分，排名是多少这样。一般不会去找某个玩家排名是多少
那客户端打开排行榜页面的时候，他肯定是一屏一屏打开嘛，有做分页吗
    没有，因为我们就是大概200个这样，200个就直接给它返回了
如果做分页你有了解怎么做吗
    分页的话我们目前就是遍历一遍吧。如果需要高效率的话我觉得还是用跳表再重新实现一遍
那全服6w的榜前端是怎么来拉的
    它不是拉全量的，那种全量的榜是存在Redis嘛，一般也就是查玩家自己的排名，就直接请求Redis去找某个UID对应的排名了
那这个排行榜其实是个独立的服务器，其他服里产生数据就丢给它是吧
如果宕机了或者丢失了有做什么处理吗
    我们这边是会定期去保存一下，比如5秒或者10秒保存到Redis
如果系统宕机了就5秒内会丢失吗
    会丢失
Redis这块熟悉吗
    熟悉吧（不会又打脸吧）
Redis一条命令最大不超过多少兆你知道吗
    （怎么又问这种冷门的问题）不知道
那你们整个榜如果存的话，一个玩家是单独存，不是一起落地是吧
    那种全量的就是一个玩家单独存了

我看除了排行榜这块，还做了其他的大型的玩法有吗
    大型的没有
有做跨服的玩法吗
    没做跨服的玩法（尬住了）
我看你还做了一个协议的频率限制，这块就是限制客户端同一秒内能发多少频率是吧
    对，我们是每一个玩家去限制的
死循环检测是怎么检测的
    死循环检测它是类似于一个看门狗的功能。就是我的worker线程，在处理完消息之后，会向状态统计那边上报一下，就是更新一个时间戳。然后另外有一个监控线程，就是监控所有线程的时间戳，如果时间戳很久没有被更新了，那么说明这个线程可能被卡住了，就是可能死循环

你们是C++还是Go的
可以讲一讲是什么样的架构吗
前面那个dispatch那个东西是用来做客户端路由的是不是
    就是帮助客户端找到一个连接的服务器嘛
它怎么知道哪个网关空闲一点呢
    网关会定期向dispatch上报它的负载情况，dispatch就知道每一台gateserver的负载情况
那你们这个dispatch是不是多开的
    都是多开的
你们这个nodeserver的意义是为了路由到不同的dbserver或者mailserver对吧
    就是把所有的我们服务器各个进程给连接起来
比如玩家的跨服玩法的话你们是会在nodeserver后面挂一个跨服的服是吧
    （有一个叫crossserver，我的图上没有画）
玩家的跨服玩法的消息路由是什么样的
    就通过gameserver到nodeserver到一个跨服的服务器嘛
nodeserver这块你们是专门定义了一种类型的消息转发是吧
    我们会把消息转发的方式写到消息头里面。就是你要路由到哪一台服务器啊，用的是哈希，还是随机，还是一致性哈希，还是广播之类的
这一套架构你有在里面去参与吗，还是去的时候就是这个架构了
    我去的时候就是这样了
那我再问个问题，如果我要在跨服玩法里面要去gameserver去扣玩家的一个东西，会是怎么扣
    （开始瞎编）像这种的话可能需要一个补偿的功能，因为跨服的话可能会丢包
    像这种的话我们一般就是把这种消息发到mailserver里面，因为mailserver会进行一个消息的落地，然后会通知一下gameserver去处理
    那如果这个包丢了，下次玩家上线的时候会向mailserver查询一下有没有没处理的消息，然后继续处理
那你这个server发到mailserver不也可能会丢吗
    所以就是每一级需要一个重试的机制吧。比如我在内存里缓存一下，哪些包没有被确认的，然后发到对应的服务器需要发回一个确认的包，确认之后才可以把这个缓存给清除掉，否则就会定期重试去发
那这块的逻辑你们服务器里有吗
    有的，一些邮件的话其实就是这种机制

你去之前已经上线了是吧
有没有遇到什么线上的问题，印象深刻的问题
    最严重的可能就是遇到了coredump这样的问题，就是线上这个服务器崩溃了，生成了一个coredump
有没有其他什么业务逻辑写得出问题了，排查的过程中印象深刻的例子
    也就是一些奖励漏发了吧，标志打错了之类的
    像这种的话我们一般就是，我们日志会做得很全面，比如完成了某一个任务啊，完成了某些条件，或者领取奖励什么的都会有日志。我们是通过日志去排查，就是拉一下他达成了某个条件，但是又没有领到某个奖励的，然后用运营的手段去补发
那你们日志是打本地的日志还是记到某个平台的
    我们都是打到本地日志的，但是会有另外一个工具把它给收集起来

你们用了libco那个库是吧，那个库应该是一个协程库是吧
你们网络那块用的是select还是epoll
    我们是直接用了Asio的
就是这个框架给你封了一个库是吧
那你了解select和epoll吗，它们有啥区别
    它主要是三种吧，有select、poll还有epoll
    select还有poll它内部是用轮询去实现的，而且每一次调用都要把文件描述符从用户态拷到内核态，然后返回的时候也要从内核态拷到用户态，这个会比较耗时。而且用户收到这一大堆文件描述符，你还要再遍历一遍，看看哪一些是有事件的
    epoll的话它其实就是优化了这一些，epoll内部是用回调去实现的，所以当文件描述符增加的时候，性能不会变差。然后它内部是用了红黑树还有链表，链表是作为一个就绪的队列，回调函数里面就是把就绪的事件放到这个就绪队列里面，wait的时候就是关注这个就绪队列，只把那些就绪的事件拷贝给用户，就不会把所有事件都拷贝给用户
    然后epoll是支持水平触发和边缘触发的，select和poll是只支持水平触发
水平触发和边缘触发有啥区别
    水平触发就是只要这个文件描述符还能够读，就会不停给你返回这个时间
    边缘触发就是当他第一次能读时给你返回这个事件，但是如果你不把它给读完，那下一次就不会返回这个事件了
那一般项目中用什么
    我的话一般用水平触发，因为实现起来比较简单吧
但是水平触发性能没有边缘触发好吧，因为水平触发它是一直会有消息让你读吧
    但理论上，其实有消息就应该去读

在（上家项目）主要是偏外围系统开发的吗
    就是辅助开发的一些工具吧
你哪个工具最自豪
    模拟抽卡这个会比较有意思
模拟抽卡是不是就用服务器的表写一套相同的逻辑
    我们是直接用一个机器人去模拟客户端发送请求的，请求完了去服务器日志里面统计这个结果，看抽出来统计出来的概率是不是和预期一样
你们这个工具箱是什么东西，架构是什么样的
    我是做了一个B/S架构，辅助开发的工具嘛。里面会有很多很多功能，比如可以拷贝账号到指定区服，发送GM命令，还有发布一些服务器配置，包括刚才的模拟抽卡也在这里面
他界面展示是一个网页的还是什么
    就一个网页的，然后项目组里面各种职能都可以去用。比如策划、运营、QA，可以用过这个工具来操作服务器
有截图展示吗
    没有截图（内网信息怎么会随便让你截图）
这个东西其实就是你从头开始搭建的
这块后台用的什么，Python吗
    用的Python
那前端呢
    前端用的是Vue那个框架
就是JS这块也是懂的是吧

在（上家项目）有做业务开发吗
    没有，后面就是专门做工具了
就是业务开发和工具开发你本身是倾向哪一块
    我当然是更喜欢业务开发
它们开发的注意事项有什么区别，为什么更喜欢业务
    我觉得业务可能对整个项目贡献更加多吧，可能你做工具的话没有多少人能够发现，可能不知道贡献有没有1%这样
工具开发是领导分配的还是很多东西是你自己探索发现的
    都有吧，有时候就是可能运营、策划、QA那边提一些需求或者反馈什么的，希望加一个功能或者改进某一些方面什么的。另一方面就是我自己开发的时候有没有发现什么痛点啊，或者我们服务器组里面有什么需求啊，就去做一下

Go这块有了解吗
    了解一点，就是我刚把官方那个Go之旅给看完了。我对它协程比较感兴趣所以就了解一点

我看你之前提到红黑树，红黑树这块的算法逻辑有了解吗
    我知道它一些特点啊。就是它算是一个弱平衡的二叉搜索树嘛，可以保证最长的路径不超过最短路径的两倍这样
    （没有追问就不背那5个性质了）
我们查询比较快是什么原因会很快
    二叉搜索树的话它查询快是因为，一次可以排除掉大概一半的数据嘛。那如果这个树不平衡的话，它其实就退化成一个链表，排除掉的数据就比较少。所以我们是尽量让这个二叉搜索树平衡

你还用Jenkins搭了一些运维平台是吧
    不算是运维的。我们本来就有一些Jenkins任务，我是后面接手然后把它维护得更好吧

最近有在看什么书吗
    最近的话主要就是看一些Go语言吧，最近在学

TCP这块的三次握手过程能讲一讲吗
    第一次就是客户端给服务器发一个SYN包，seq是一个随机数
    然后服务器收到之后给客户端回一个ACK + SYN，然后ack是客户端发的seq + 1，它的seq是另一个随机数
    客户端收到这个就向服务器回一个ACK，它的ack是服务器的seq + 1
为什么要用三次握手
    我们创建连接其实就是确认双方能不能互相通信的一个过程
    第一次握手是服务器知道了客户端能发送到服务器上
    第二次是客户端知道了客户端能发到服务器，服务器能发到客户端
    第三次是服务器知道了服务器能发到客户端

多线程这块的线程数据同步有哪种方式呢
    互斥锁、读写锁、条件变量、信号量这些
平时工作中有用到吗
    一般就用互斥锁吧

MySQL和MongoBD有什么比较大的区别
    MySQL它是一个关系型数据库，MongoDB是一个非关系型数据库
    MySQL的话关系型的，它就是用行和列这种二维的表格去组织数据。NoSQL的话可以不用这种形式，像MongoDB它是用了文档型的形式，就是它内部其实存储了像JSON文档这样的数据
    MySQL的话它的事务是提供ACID保证的，MongoDB不提供这些保证
你们（上家项目）用的是MySQL还是MongoDB
    我们用的MySQL
你们设计的表结构是什么样的
    用户数据的话还是比较简单的，主要就是UID，然后像等级、经验这些我们是作为一个字段的，其他一些我们都是序列化之后再存储到一个字段里面
落地的时候是一个proto一起落地是吧
你们大概是多久落地一次
    定期的话是2分钟一次，我们还有另一种，就是如果你修改了什么重要的数据，会手动触发一次
如果给服务器关机了，kill的时候，会落地不
    只要不是强制的，因为平时停服就是发送一个SIGTERM的信号嘛。收到SIGTERM我们这边会设置一个标志位，说要停机了，然后会把所有玩家都给踢掉。踢下线首先就会把玩家数据给落地到数据库，然后才能下线，所有玩家都下线完之后这个进程才会关闭
你们是怎么保证所有玩家全下线了进程才关闭的
    我们有一个缓存嘛，就是向dbserver发送一个保存请求之后我们这边会把用户数据给缓存下来，然后等待dbserver的回包。只有dbserver回复了已经保存成功了，才把这个缓存给清掉，这个玩家才算是完全地下线了

登录这块有了解吗，就是客户端点登录的整个流程，你能讲一下吗
    客户端登录的话是先从dispatch查询gateserver，然后（被打断）
等一下，我讲的是从SDK那块，你们有外围的登录服吗
    没有登录服，我们会有一个验证账号的平台吧
这块考虑在内，它是一个怎样的交互流程
    客户端向gateserver发送一个认证请求，gateserver是会向外部平台认证一下，客户端这个token对不对这样
gateserver跟外部那个是直连的是吧
    是用一个HTTP的接口

你们这个活动系统是什么
活动就是业务开发是吧
    是的，我们每个版本会出一些小活动吧
战斗这块有参与吗，有了解过吗
    我们都是客户端去计算的，我们服务器只是接收客户端的结果
那服务器怎么去校验，不校验客户端的结果吗
    有些加密什么的
纯相信客户端，在协议包里面加密是吧

你们协议包的结构是什么样的
    是这样的，头尾的话我们有一些魔数，就magic number，magic number后面是头部的长度、body的长度，还有cmd号，后面是一个序列化的自定义头部，然后序列化的body
前面这个magic number是干嘛的
    用来识别一个包的头部和尾部的，用来校验一个包是不是坏包什么的
用这个包的长度校验不了吗，你怕发其他的东西过来
    我们会根据长度去读取一个包，读取完之后再判断后面的字节是不是一个magic number
如果不是怎么办
    如果不是我们就判断这可能是一个坏包，然后就把它丢弃了
线上有遇到过这种情况吗
    有一些吧，主要是一些玩家可能网络不太好，突然就断线了，或者突然缓冲区就满了
那如果不用magic number是不是更好呢，假如这个包只发了一部分，先缓存在那里不读。因为这个包可能还是一个正常的包吧，跟下一段拼在一起它可能还是一个完整的包
    （是这样处理的啊，但还是有可能有坏包）
那你们现在坏包是客户端会重发还是怎样
    我们大部分数据其实是可以丢掉的，但如果是重要的数据包就会重发，比如一些结算的数据包
客户端到服务器包的长度有限制吗
    有限制，应该是512K这样吧
服务器到客户端呢
    都一样的
如果一个包超过上限你们会怎么处理
    这种也是会丢掉的，因为可能要么是一个坏包，要么是有黑客攻击什么的
如果业务逻辑上，服务器要发一个东西给客户端，可能超过这个上限，要怎么搞
    这种其实之前没有遇到，因为如果有这种我们会打一条错误日志，错误日志就会触发我们运维的告警。如果真的发现这种情况的话，我们就会看一下这个包能不能优化一下，就是减少它的大小
那还有其他方法吗
    因为正常来说其实不应该出现这么大的包的
那比如请求排行榜，可能它发错了，请求1到1w，全给它发了
    像这种其实是BUG，其实应该修复的
还有一种情况，假设你们的战报很大，就是很大，随着业务逻辑增多就是会很大。除了提高上限还有什么方法
    可能比如可以分成多个包来发，然后服务器这边做一个缓存，等多个包发过来之后再拼成一个完整的这样
就是相当于分包是吧，分包这块如果你来设计你怎么设计
    我感觉这个不应该做在网络层，因为网络层限制就是512K这么大
没说做在网络层
    可能是在玩家数据上面记一个类似于封包的数组，然后来一个包就往里面填充一下
我讲的是服务器到客户端
    其实也一样的，先把这个包给序列化了，序列化变成一个字符串这样，把它分成大小差不多到上限的几个包。然后把它发给客户端，由客户端自己拼接起来
那客户端怎么保证我收到的这些包是要拼在一起的呢
    我们可以记一个总的包的大小，还有包的序列化，就总的包有几个，这是第几个包这样
给它加一个唯一的ID是吧，然后再告诉它一共有几个包

那个（上家另一个项目）这块的服务器大概有了解吗
    和刚才差不多的
你们服务器架构啥的内部应该都一套对吧
    我们（上家项目）这边是这样

离职原因

在（上家项目）的话你们服务器是多少人
你们人员配置还挺高的

反问
    你们的技术栈是什么样的，或者有用框架之类的吗
        我们是自研的框架，后台的话用的是Go（你们JD一个字都没提到Go）
    我看这个岗位应该是招C++的服务器啊
        我们招过来的人吧，包括我自己在内也都是C++过来的，但那边是Go嘛
        Go和C++你还是倾向C++是吗
            我都可以，我对Go还是挺感兴趣的，现在也是在学嘛（你们不嫌我菜的话）
        一般用了Go就回不去了
    工作氛围怎么样
        应该都还可以吧，后端X个人，前端X个人吧（人数有点少），大家氛围都还可以（感觉什么都没说啊）


------
感觉问的还是比较杂的，中间还有一些纯八股文，也没有很深入问。听说阿里技术面是有三面，可能后面会更深入一些
三天后凉了，可能他们还是要做过大型系统的
